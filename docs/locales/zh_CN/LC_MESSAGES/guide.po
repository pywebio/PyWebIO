# SOME DESCRIPTIVE TITLE.
# Copyright (C) WangWeimin
# This file is distributed under the same license as the PyWebIO package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2021.
#
msgid ""
msgstr ""
"Project-Id-Version: PyWebIO 1.1.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-11-16 23:13+0800\n"
"PO-Revision-Date: 2021-12-02 21:46+0800\n"
"Last-Translator: WangWeimin <wang0.618@qq.com>\n"
"Language: zh_CN\n"
"Language-Team: \n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.8.0\n"
"X-Generator: Poedit 3.0\n"

#: ../../guide.rst:2
msgid "User's guide"
msgstr ""

#: ../../guide.rst:4
msgid ""
"If you are familiar with web development, you may not be accustomed to the usage of PyWebIO described below, which is different from the "
"traditional web development pattern that backend implement api and frontend display content. In PyWebIO, you only need to write code in Python."
msgstr ""
"å¦‚æœä½ æ¥è§¦è¿‡Webå¼€å‘ï¼Œä½ å¯èƒ½å¯¹æ¥ä¸‹æ¥æè¿°çš„PyWebIOçš„ç”¨æ³•æ„Ÿåˆ°ä¸å¤ªä¹ æƒ¯ï¼Œä¸åŒäºä¼ ç»ŸWebå¼€å‘çš„åç«¯å®ç°æ¥å£ã€å‰ç«¯è¿›è¡Œå±•ç¤ºäº¤äº’çš„æ¨¡å¼ï¼Œåœ¨PyWebIOä¸­ï¼Œæ‰€æœ‰çš„é€»è¾‘"
"éƒ½é€šè¿‡ç¼–å†™Pythonä»£ç å®ç°ã€‚"

#: ../../guide.rst:8
msgid ""
"In fact, the way of writing PyWebIO applications is more like writing a console program, except that the terminal here becomes a browser. Using the "
"imperative API provided by PyWebIO, you can simply call ``put_text()``, ``put_image()``, ``put_table()`` and other functions to output text, "
"pictures, tables and other content to the browser, or you can call some functions such as ``input()``, ``select()``, ``file_upload()`` to display "
"different forms on the browser to get user input. In addition, PyWebIO also provides support for click events, layout, etc. PyWebIO aims to allow "
"you to use the least code to interact with the user and provide a good user experience as much as possible."
msgstr ""
"ä½ å¯ä»¥æŒ‰ç…§ç¼–å†™æ§åˆ¶å°ç¨‹åºçš„é€»è¾‘ç¼–å†™PyWebIOåº”ç”¨ï¼Œåªä¸è¿‡è¿™é‡Œçš„ç»ˆç«¯å˜æˆäº†æµè§ˆå™¨ã€‚é€šè¿‡PyWebIOæä¾›çš„å‘½ä»¤å¼APIï¼Œä½ å¯ä»¥ç®€å•åœ°è°ƒç”¨ ``put_text()`` ã€ "
"``put_image()`` ã€ ``put_table()`` ç­‰å‡½æ•°è¾“å‡ºæ–‡æœ¬ã€å›¾ç‰‡ã€è¡¨æ ¼ç­‰å†…å®¹åˆ°æµè§ˆå™¨ï¼Œä¹Ÿå¯ä»¥è°ƒç”¨ ``input()`` ã€ ``select()`` ã€ ``file_upload()`` ç­‰å‡½æ•°åœ¨æµ"
"è§ˆå™¨ä¸Šæ˜¾ç¤ºä¸åŒè¡¨å•æ¥æ¥æ”¶ç”¨æˆ·çš„è¾“å…¥ã€‚æ­¤å¤–PyWebIOä¸­è¿˜æä¾›äº†ç‚¹å‡»äº‹ä»¶ã€å¸ƒå±€ç­‰æ”¯æŒï¼Œè®©ä½ å¯ä»¥ä½¿ç”¨æœ€å°‘çš„ä»£ç å®Œæˆä¸ç”¨æˆ·çš„äº¤äº’ï¼Œå¹¶å°½å¯èƒ½æä¾›è‰¯å¥½çš„ç”¨æˆ·ä½“éªŒã€‚"

#: ../../guide.rst:15
msgid ""
"This user guide introduces you the most of the features of PyWebIO. There is a demo link at the top right of the example codes in this document, "
"where you can run the example code online and see what happens."
msgstr ""
"æœ¬ç¯‡ä½¿ç”¨æŒ‡å—ä»å‡ ä¸ªæ–¹é¢å¯¹PyWebIOçš„ä½¿ç”¨è¿›è¡Œä»‹ç»ï¼Œè¦†ç›–äº†PyWebIOçš„ç»å¤§éƒ¨åˆ†ç‰¹æ€§ã€‚æœ¬æ–‡æ¡£ä¸­å¤§éƒ¨åˆ†ç¤ºä¾‹ä»£ç çš„å³ä¸Šæ–¹éƒ½æœ‰ä¸€ä¸ªDemoé“¾æ¥ï¼Œç‚¹å‡»åå¯ä»¥åœ¨çº¿é¢„è§ˆä»£ç çš„"
"è¿è¡Œæ•ˆæœã€‚"

#: ../../guide.rst:19
msgid "Input"
msgstr "è¾“å…¥"

#: ../../guide.rst:21
msgid "The input functions are defined in the :doc:`pywebio.input </input>` module and can be imported using ``from pywebio.input import *``."
msgstr "è¾“å…¥å‡½æ•°éƒ½å®šä¹‰åœ¨ :doc:`pywebio.input </input>` æ¨¡å—ä¸­ï¼Œå¯ä»¥ä½¿ç”¨ ``from pywebio.input import *`` å¼•å…¥ã€‚"

#: ../../guide.rst:23
msgid ""
"When calling the input function, an input form  will be popped up on the browser. PyWebIO's input functions is blocking (same as Python's built-in "
"``input()`` function) and will not return until the form is successfully submitted."
msgstr ""
"è°ƒç”¨è¾“å…¥å‡½æ•°ä¼šåœ¨æµè§ˆå™¨ä¸Šå¼¹å‡ºä¸€ä¸ªè¾“å…¥è¡¨å•æ¥è·å–è¾“å…¥ã€‚PyWebIOçš„è¾“å…¥å‡½æ•°æ˜¯é˜»å¡å¼çš„ï¼ˆå’ŒPythonå†…ç½®çš„ `input` ä¸€æ ·ï¼‰ï¼Œåœ¨è¡¨å•è¢«æˆåŠŸæäº¤ä¹‹å‰ï¼Œè¾“å…¥å‡½æ•°ä¸ä¼šè¿”"
"å›ã€‚"

#: ../../guide.rst:27
msgid "Basic input"
msgstr "åŸºæœ¬è¾“å…¥"

#: ../../guide.rst:29
msgid "Here are some basic types of input."
msgstr "é¦–å…ˆæ˜¯ä¸€äº›åŸºæœ¬ç±»å‹çš„è¾“å…¥ã€‚"

#: ../../guide.rst:31
msgid "Text input:"
msgstr "æ–‡æœ¬è¾“å…¥:"

#: ../../guide.rst:33
#, python-format
msgid ""
"age = input(\"How old are you?\", type=NUMBER)\n"
"put_text('age = %r' % age)  # ..demo-only"
msgstr ""

#: ../../guide.rst:40
msgid ""
"After running the above code, the browser will pop up a text input field to get the input. After the user completes the input and submits the form, "
"the function returns the value entered by the user."
msgstr "è¿™æ ·ä¸€è¡Œä»£ç çš„æ•ˆæœä¸ºï¼šæµè§ˆå™¨ä¼šå¼¹å‡ºä¸€ä¸ªæ–‡æœ¬è¾“å…¥æ¡†æ¥è·å–è¾“å…¥ï¼Œåœ¨ç”¨æˆ·å®Œæˆè¾“å…¥å°†è¡¨å•æäº¤åï¼Œå‡½æ•°è¿”å›ç”¨æˆ·è¾“å…¥çš„å€¼ã€‚"

#: ../../guide.rst:43
msgid "Here are some other types of input functions:"
msgstr "ä¸‹é¢æ˜¯ä¸€äº›å…¶ä»–ç±»å‹çš„è¾“å…¥å‡½æ•°:"

#: ../../guide.rst:45
#, python-format
msgid ""
"# Password input\n"
"password = input(\"Input password\", type=PASSWORD)\n"
"put_text('password = %r' % password)  # ..demo-only\n"
"## ----\n"
"\n"
"# Drop-down selection\n"
"gift = select('Which gift you want?', ['keyboard', 'ipad'])\n"
"put_text('gift = %r' % gift)  # ..demo-only\n"
"## ----\n"
"\n"
"# Checkbox\n"
"agree = checkbox(\"User Term\", options=['I agree to terms and conditions'])\n"
"put_text('agree = %r' % agree)  # ..demo-only\n"
"## ----\n"
"\n"
"# Single choice\n"
"answer = radio(\"Choose one\", options=['A', 'B', 'C', 'D'])\n"
"put_text('answer = %r' % answer)  # ..demo-only\n"
"## ----\n"
"\n"
"# Multi-line text input\n"
"text = textarea('Text Area', rows=3, placeholder='Some text')\n"
"put_text('text = %r' % text)  # ..demo-only\n"
"## ----\n"
"\n"
"# File Upload\n"
"img = file_upload(\"Select a image:\", accept=\"image/*\")\n"
"if img:    # ..demo-only\n"
"    put_image(img['content'], title=img['filename'])  # ..demo-only"
msgstr ""
"# å¯†ç è¾“å…¥\n"
"password = input(\"Input password\", type=PASSWORD)\n"
"put_text('password = %r' % password)  # ..demo-only\n"
"## â€”â€”\n"
"\n"
"# ä¸‹æ‹‰é€‰æ‹©æ¡†\n"
"gift = select('Which gift you want?', ['keyboard', 'ipad'])\n"
"put_text('gift = %r' % gift)  # ..demo-only\n"
"## â€”â€”\n"
"\n"
"# å‹¾é€‰é€‰é¡¹\n"
"agree = checkbox(\"ç”¨æˆ·åè®®\", options=['I agree to terms and conditions'])\n"
"put_text('agree = %r' % agree)  # ..demo-only\n"
"## â€”â€”\n"
"\n"
"# å•é€‰é€‰é¡¹\n"
"answer = radio(\"Choose one\", options=['A', 'B', 'C', 'D'])\n"
"put_text('answer = %r' % answer)  # ..demo-only\n"
"## â€”â€”\n"
"\n"
"# å¤šè¡Œæ–‡æœ¬è¾“å…¥\n"
"text = textarea('Text Area', rows=3, placeholder='Some text')\n"
"put_text('text = %r' % text)  # ..demo-only\n"
"## â€”â€”\n"
"\n"
"# æ–‡ä»¶ä¸Šä¼ \n"
"img = file_upload(\"Select a image:\", accept=\"image/*\")\n"
"if img:    # ..demo-only\n"
"    put_image(img['content'], title=img['filename'])  # ..demo-only"

#: ../../guide.rst:81
msgid "Parameter of input functions"
msgstr "è¾“å…¥é€‰é¡¹"

#: ../../guide.rst:83
msgid ""
"There are many parameters that can be passed to the input function(for complete parameters, please refer to the :doc:`function document </input>`):"
msgstr "è¾“å…¥å‡½æ•°å¯æŒ‡å®šçš„å‚æ•°éå¸¸ä¸°å¯Œï¼ˆå…¨éƒ¨å‚æ•°åŠå«ä¹‰è¯·è§ :doc:`å‡½æ•°æ–‡æ¡£ </input>` ï¼‰:"

#: ../../guide.rst:86
msgid ""
"input('This is label', type=TEXT, placeholder='This is placeholder',\n"
"        help_text='This is help text', required=True)"
msgstr ""

#: ../../guide.rst:93 ../../guide.rst:129 ../../guide.rst:279 ../../guide.rst:586
msgid "The results of the above example are as follows:"
msgstr "ä»¥ä¸Šä»£ç å°†åœ¨æµè§ˆå™¨ä¸Šæ˜¾ç¤ºå¦‚ä¸‹ï¼š"

#: ../../guide.rst:97
msgid ""
"You can specify a validation function for the input by using ``validate`` parameter. The validation function should return ``None`` when the check "
"passes, otherwise an error message will be returned:"
msgstr "æˆ‘ä»¬å¯ä»¥ä¸ºè¾“å…¥æŒ‡å®šæ ¡éªŒå‡½æ•°ï¼Œæ ¡éªŒå‡½æ•°åº”åœ¨æ ¡éªŒé€šè¿‡æ—¶è¿”å›Noneï¼Œå¦åˆ™è¿”å›é”™è¯¯æ¶ˆæ¯:"

#: ../../guide.rst:100
#, python-format
msgid ""
"def check_age(p):  # return None when the check passes, otherwise return the error message\n"
"    if p < 10:\n"
"        return 'Too young!!'\n"
"    if p > 60:\n"
"        return 'Too old!!'\n"
"\n"
"age = input(\"How old are you?\", type=NUMBER, validate=check_age)\n"
"put_text('age = %r' % age)  # ..demo-only"
msgstr ""

#: ../../guide.rst:113
msgid "When the user input an illegal value, the input field is displayed as follows:"
msgstr "å½“ç”¨æˆ·è¾“å…¥äº†ä¸åˆæ³•çš„å€¼æ—¶ï¼Œé¡µé¢ä¸Šçš„æ˜¾ç¤ºå¦‚ä¸‹:"

#: ../../guide.rst:117
msgid "You can use ``code`` parameter in :func:`pywebio.input.textarea()` to make a code editing textarea."
msgstr ":func:`pywebio.input.textarea()`  ä¸­å¯ä»¥ä½¿ç”¨ ``code`` å‚æ•°æ¥å¼€å¯ä»£ç é£æ ¼çš„ç¼–è¾‘åŒºã€‚"

#: ../../guide.rst:119
msgid ""
"code = textarea('Code Edit', code={\n"
"    'mode': \"python\",\n"
"    'theme': 'darcula',\n"
"}, value='import something\\n# Write your python code')\n"
"put_code(code, language='python')  # ..demo-only"
msgstr ""

#: ../../guide.rst:135
msgid "Input Group"
msgstr "è¾“å…¥ç»„"

#: ../../guide.rst:137
msgid ""
"PyWebIO uses input group to get multiple inputs in a single form. `pywebio.input.input_group()` accepts a list of single input function call as "
"parameter, and returns a dictionary with the ``name`` of the single input as its key and the input data as its value:"
msgstr ""
"PyWebIOæ”¯æŒè¾“å…¥ç»„, è¿”å›ç»“æœä¸ºä¸€ä¸ªå­—å…¸ã€‚`pywebio.input.input_group()` æ¥å—å•é¡¹è¾“å…¥ç»„æˆçš„åˆ—è¡¨ä½œä¸ºå‚æ•°, è¿”å›ä»¥å•é¡¹è¾“å…¥ä¸­çš„ ``name`` ä½œä¸ºé”®ã€ä»¥è¾“å…¥æ•°æ®"
"ä¸ºå€¼çš„å­—å…¸:"

#: ../../guide.rst:142
msgid ""
"def check_age(p):  # ..demo-only\n"
"    if p < 10:                  # ..demo-only\n"
"        return 'Too young!!'    # ..demo-only\n"
"    if p > 60:                  # ..demo-only\n"
"        return 'Too old!!'      # ..demo-only\n"
"                                # ..demo-only\n"
"data = input_group(\"Basic info\",[\n"
"  input('Input your name', name='name'),\n"
"  input('Input your age', name='age', type=NUMBER, validate=check_age)\n"
"])\n"
"put_text(data['name'], data['age'])"
msgstr ""

#: ../../guide.rst:158
msgid "The input group also supports using ``validate`` parameter to set the validation function, which accepts the entire form data as parameter:"
msgstr "è¾“å…¥ç»„ä¸­åŒæ ·æ”¯æŒä½¿ç”¨ ``validate`` å‚æ•°è®¾ç½®æ ¡éªŒå‡½æ•°ï¼Œå…¶æ¥å—æ•´ä¸ªè¡¨å•æ•°æ®ä½œä¸ºå‚æ•°:"

#: ../../guide.rst:160
msgid ""
"def check_age(p):  # single input item validation  # ..demo-only\n"
"    if p < 10:                  # ..demo-only\n"
"        return 'Too young!!'    # ..demo-only\n"
"    if p > 60:                  # ..demo-only\n"
"        return 'Too old!!'      # ..demo-only\n"
"                                # ..demo-only\n"
"def check_form(data):  # return (input name, error msg) when validation fail\n"
"    if len(data['name']) > 6:\n"
"        return ('name', 'Name too long!')\n"
"    if data['age'] <= 0:\n"
"        return ('age', 'Age can not be negative!')\n"
"\n"
"data = input_group(\"Basic info\",[           # ..demo-only\n"
"   input('Input your name', name='name'),   # ..demo-only\n"
"   input('Input your age', name='age', type=NUMBER, validate=check_age)  # ..demo-only\n"
"], validate=check_form)              # ..demo-only\n"
"put_text(data['name'], data['age'])    # ..demo-only"
msgstr ""

#: ../../guide.rst:183
msgid ""
"PyWebIO determines whether the input function is in `input_group()` or is called alone according to whether the ``name`` parameter is passed. So "
"when calling an input function alone, **do not** set the ``name`` parameter; when calling the input function in `input_group()`, you **must** "
"provide the ``name`` parameter."
msgstr ""
"PyWebIO æ ¹æ®æ˜¯å¦åœ¨è¾“å…¥å‡½æ•°ä¸­ä¼ å…¥ ``name`` å‚æ•°æ¥åˆ¤æ–­è¾“å…¥å‡½æ•°æ˜¯åœ¨ `input_group()` ä¸­è¿˜æ˜¯è¢«å•ç‹¬è°ƒç”¨ã€‚æ‰€ä»¥å½“å•ç‹¬è°ƒç”¨ä¸€ä¸ªè¾“å…¥å‡½æ•°æ—¶, **ä¸è¦** è®¾ç½® "
"``name`` å‚æ•°ï¼›è€Œåœ¨ `input_group()` ä¸­è°ƒç”¨è¾“å…¥å‡½æ•°æ—¶ï¼Œéœ€ **åŠ¡å¿…æä¾›** ``name`` å‚æ•°ã€‚"

#: ../../guide.rst:188
msgid "Output"
msgstr "è¾“å‡º"

#: ../../guide.rst:190
msgid "The output functions are all defined in the :doc:`pywebio.output </output>` module and can be imported using ``from pywebio.output import *``."
msgstr "è¾“å‡ºå‡½æ•°éƒ½å®šä¹‰åœ¨ :doc:`pywebio.output </output>` æ¨¡å—ä¸­ï¼Œå¯ä»¥ä½¿ç”¨ ``from pywebio.output import *`` å¼•å…¥ã€‚"

#: ../../guide.rst:193
msgid ""
"When output functions is called, the content will be output to the browser in real time. The output functions can be called at any time during the "
"application lifetime."
msgstr "è°ƒç”¨è¾“å‡ºå‡½æ•°åï¼Œå†…å®¹ä¼šå®æ—¶è¾“å‡ºåˆ°æµè§ˆå™¨ï¼Œåœ¨åº”ç”¨çš„ç”Ÿå‘½å‘¨æœŸå†…ï¼Œå¯ä»¥åœ¨ä»»æ„æ—¶åˆ»è°ƒç”¨è¾“å‡ºå‡½æ•°ã€‚"

#: ../../guide.rst:197
msgid "Basic Output"
msgstr "åŸºæœ¬è¾“å‡º"

#: ../../guide.rst:199
msgid "Using output functions, you can output a variety of content, such as text, tables, images and so on:"
msgstr "PyWebIOæä¾›äº†ä¸€ç³»åˆ—å‡½æ•°æ¥è¾“å‡ºæ–‡æœ¬ã€è¡¨æ ¼ã€å›¾åƒç­‰æ ¼å¼:"

#: ../../guide.rst:201
msgid ""
"# Text Output\n"
"put_text(\"Hello world!\")\n"
"## ----\n"
"\n"
"# Table Output\n"
"put_table([\n"
"    ['Commodity', 'Price'],\n"
"    ['Apple', '5.5'],\n"
"    ['Banana', '7'],\n"
"])\n"
"## ----\n"
"\n"
"# Image Output\n"
"put_image(open('/path/to/some/image.png', 'rb').read())  # local image # ..doc-only\n"
"put_image('http://example.com/some-image.png')  # internet image # ..doc-only\n"
"put_image('https://www.python.org/static/img/python-logo.png')  # ..demo-only\n"
"## ----\n"
"\n"
"# Markdown Output\n"
"put_markdown('~~Strikethrough~~')\n"
"## ----\n"
"\n"
"# File Output\n"
"put_file('hello_word.txt', b'hello word!')\n"
"## ----\n"
"\n"
"# Show a PopUp\n"
"popup('popup title', 'popup text content')\n"
"\n"
"# Show a notification message\n"
"toast('New message ğŸ””')"
msgstr ""

#: ../../guide.rst:238
msgid ""
"For all output functions provided by PyWebIO, please refer to the :doc:`pywebio.output </output>` module. In addition, PyWebIO also supports data "
"visualization with some third-party libraries, see :doc:`Third-party library ecology </libraries_support>`."
msgstr ""
"PyWebIOæä¾›çš„å…¨éƒ¨è¾“å‡ºå‡½æ•°è§ :doc:`pywebio.output </output>` æ¨¡å—ã€‚å¦å¤–ï¼ŒPyWebIOè¿˜æ”¯æŒä¸€äº›ç¬¬ä¸‰æ–¹åº“æ¥è¿›è¡Œæ•°æ®å¯è§†åŒ–ï¼Œå‚è§ :doc:`ç¬¬ä¸‰æ–¹åº“ç”Ÿæ€ </"
"libraries_support>` ã€‚"

#: ../../guide.rst:245
msgid ""
"If you use PyWebIO in interactive execution environment of Python shell, IPython or jupyter notebook, you need call `show()` method explicitly to "
"show output::"
msgstr "å¦‚æœä½ åœ¨Python shell, IPython æˆ– jupyter notebookè¿™ç§äº¤äº’å¼æ‰§è¡Œç¯å¢ƒä¸­ä½¿ç”¨PyWebIOï¼Œä½ éœ€è¦æ˜¾å¼è°ƒç”¨ `show()` æ–¹æ³•æ¥æ˜¾ç¤ºè¾“å‡º::"

#: ../../guide.rst:248
msgid ""
">>> put_text(\"Hello world!\").show()\n"
">>> put_table([\n"
"...     ['A', 'B'],\n"
"...     [put_markdown(...), put_text('C')]\n"
"... ]).show()"
msgstr ""

#: ../../guide.rst:258
msgid "Combined Output"
msgstr "ç»„åˆè¾“å‡º"

#: ../../guide.rst:260
msgid "The output functions whose name starts with ``put_`` can be combined with some output functions as part of the final output:"
msgstr "å‡½æ•°åä»¥ ``put_`` å¼€å§‹çš„è¾“å‡ºå‡½æ•°ï¼Œå¯ä»¥ä¸ä¸€äº›è¾“å‡ºå‡½æ•°ç»„åˆä½¿ç”¨ï¼Œä½œä¸ºæœ€ç»ˆè¾“å‡ºçš„ä¸€éƒ¨åˆ†ï¼š"

#: ../../guide.rst:262
msgid "You can pass ``put_xxx()`` calls to `put_table() <pywebio.output.put_table>` as cell content:"
msgstr "`put_table() <pywebio.output.put_table>` æ”¯æŒä»¥ ``put_xxx()`` è°ƒç”¨ä½œä¸ºå•å…ƒæ ¼å†…å®¹:"

#: ../../guide.rst:264
msgid ""
"put_table([\n"
"    ['Type', 'Content'],\n"
"    ['html', put_html('X<sup>2</sup>')],\n"
"    ['text', '<hr/>'],  # equal to ['text', put_text('<hr/>')]\n"
"    ['buttons', put_buttons(['A', 'B'], onclick=...)],  # ..doc-only\n"
"    ['buttons', put_buttons(['A', 'B'], onclick=put_text)],  # ..demo-only\n"
"    ['markdown', put_markdown('`Awesome PyWebIO!`')],\n"
"    ['file', put_file('hello.text', b'hello world')],\n"
"    ['table', put_table([['A', 'B'], ['C', 'D']])]\n"
"])"
msgstr ""

#: ../../guide.rst:283
msgid "Similarly, you can pass ``put_xxx()`` calls to `popup() <pywebio.output.popup>` as the popup content:"
msgstr "ç±»ä¼¼åœ°ï¼Œ `popup() <pywebio.output.popup>` ä¹Ÿå¯ä»¥å°† ``put_xxx()`` è°ƒç”¨ä½œä¸ºå¼¹çª—å†…å®¹:"

#: ../../guide.rst:285
msgid ""
"popup('Popup title', [\n"
"    put_html('<h3>Popup Content</h3>'),\n"
"    'plain html: <br/>',  # Equivalent to: put_text('plain html: <br/>')\n"
"    put_table([['A', 'B'], ['C', 'D']]),\n"
"    put_button('close_popup()', onclick=close_popup)\n"
"])"
msgstr ""

#: ../../guide.rst:296
msgid "In addition, you can use `put_widget() <pywebio.output.put_widget>` to make your own output widgets that can accept ``put_xxx()`` calls."
msgstr "å¦å¤–ï¼Œä½ å¯ä»¥ä½¿ç”¨ `put_widget() <pywebio.output.put_widget>` æ¥åˆ›å»ºå¯ä»¥æ¥å— ``put_xxx()`` çš„è‡ªå®šä¹‰è¾“å‡ºæ§ä»¶ã€‚"

#: ../../guide.rst:298
msgid "For a full list of functions that accept ``put_xxx()`` calls as content, see :ref:`Output functions list <output_func_list>`"
msgstr "æ¥å— ``put_xxx()`` è°ƒç”¨ä½œä¸ºå‚æ•°çš„å®Œæ•´è¾“å‡ºå‡½æ•°æ¸…å•è¯·è§ :ref:`è¾“å‡ºå‡½æ•°åˆ—è¡¨ <output_func_list>`"

#: ../../guide.rst:300
msgid "**Context Manager**"
msgstr "**ä¸Šä¸‹æ–‡ç®¡ç†å™¨**"

#: ../../guide.rst:302
msgid "Some output functions that accept ``put_xxx()`` calls as content can be used as context manager:"
msgstr "ä¸€äº›æ¥å— ``put_xxx()`` è°ƒç”¨ä½œä¸ºå‚æ•°çš„è¾“å‡ºå‡½æ•°æ”¯æŒä½œä¸ºä¸Šä¸‹æ–‡ç®¡ç†å™¨æ¥ä½¿ç”¨ï¼š"

#: ../../guide.rst:304
msgid ""
"with put_collapse('This is title'):\n"
"    for i in range(4):\n"
"        put_text(i)\n"
"\n"
"    put_table([\n"
"        ['Commodity', 'Price'],\n"
"        ['Apple', '5.5'],\n"
"        ['Banana', '7'],\n"
"    ])"
msgstr ""

#: ../../guide.rst:318
msgid "For a full list of functions that support context manager, see :ref:`Output functions list <output_func_list>`"
msgstr "æ”¯æŒä¸Šä¸‹æ–‡ç®¡ç†å™¨çš„å®Œæ•´å‡½æ•°æ¸…å•è¯·è§ :ref:`è¾“å‡ºå‡½æ•°åˆ—è¡¨ <output_func_list>`"

#: ../../guide.rst:324
msgid "Click Callback"
msgstr "äº‹ä»¶å›è°ƒ"

#: ../../guide.rst:326
msgid ""
"As we can see from the above, the interaction of PyWebIO has two parts: input and output. The input function of PyWebIO is blocking, a form will be "
"displayed on the user's web browser when calling input function, the input function will not return until the user submits the form. The output "
"function is used to output content to the browser in real time. The input and output behavior of PyWebIO is consistent with the console program. "
"That's why we say PyWebIO turning the browser into a \"rich text terminal\". So you can write PyWebIO applications in script programming way."
msgstr ""
"ä»ä¸Šé¢å¯ä»¥çœ‹å‡ºï¼ŒPyWebIOæŠŠäº¤äº’åˆ†æˆäº†è¾“å…¥å’Œè¾“å‡ºä¸¤éƒ¨åˆ†ï¼šè¾“å…¥å‡½æ•°ä¸ºé˜»å¡å¼è°ƒç”¨ï¼Œä¼šåœ¨ç”¨æˆ·æµè§ˆå™¨ä¸Šæ˜¾ç¤ºä¸€ä¸ªè¡¨å•ï¼Œåœ¨ç”¨æˆ·æäº¤è¡¨å•ä¹‹å‰è¾“å…¥å‡½æ•°å°†ä¸ä¼šè¿”å›ï¼›è¾“å‡º"
"å‡½æ•°å°†å†…å®¹å®æ—¶è¾“å‡ºè‡³æµè§ˆå™¨ã€‚è¿™ç§äº¤äº’æ–¹å¼å’Œæ§åˆ¶å°ç¨‹åºæ˜¯ä¸€è‡´çš„ï¼Œå› æ­¤PyWebIOåº”ç”¨éå¸¸é€‚åˆä½¿ç”¨æ§åˆ¶å°ç¨‹åºçš„ç¼–å†™é€»è¾‘æ¥è¿›è¡Œå¼€å‘ã€‚"

#: ../../guide.rst:332
msgid ""
"In addition, PyWebIO also supports event callbacks: PyWebIO allows you to output some buttons and bind callbacks to them. The provided callback "
"function will be executed when the button is clicked."
msgstr "æ­¤å¤–ï¼ŒPyWebIOè¿˜æ”¯æŒäº‹ä»¶å›è°ƒï¼šPyWebIOå…è®¸ä½ è¾“å‡ºä¸€äº›æ§ä»¶å¹¶ç»‘å®šå›è°ƒå‡½æ•°ï¼Œå½“æ§ä»¶è¢«ç‚¹å‡»æ—¶ç›¸åº”çš„å›è°ƒå‡½æ•°ä¾¿ä¼šè¢«æ‰§è¡Œã€‚"

#: ../../guide.rst:335
msgid "This is an example:"
msgstr "ä¸‹é¢æ˜¯ä¸€ä¸ªä¾‹å­:"

#: ../../guide.rst:337
#, python-format
msgid ""
"from functools import partial\n"
"\n"
"def edit_row(choice, row):\n"
"    put_text(\"You click %s button ar row %s\" % (choice, row))\n"
"\n"
"put_table([\n"
"    ['Idx', 'Actions'],\n"
"    [1, put_buttons(['edit', 'delete'], onclick=partial(edit_row, row=1))],\n"
"    [2, put_buttons(['edit', 'delete'], onclick=partial(edit_row, row=2))],\n"
"    [3, put_buttons(['edit', 'delete'], onclick=partial(edit_row, row=3))],\n"
"])"
msgstr ""

#: ../../guide.rst:353
msgid ""
"The call to `put_table() <pywebio.output.put_table>` will not block. When user clicks a button, the corresponding callback function will be invoked:"
msgstr "`put_table() <pywebio.output.put_table>` çš„è°ƒç”¨ä¸ä¼šé˜»å¡ã€‚å½“ç”¨æˆ·ç‚¹å‡»äº†æŸè¡Œä¸­çš„æŒ‰é’®æ—¶ï¼ŒPyWebIOä¼šè‡ªåŠ¨è°ƒç”¨ç›¸åº”çš„å›è°ƒå‡½æ•°:"

#: ../../guide.rst:358
msgid "Of course, PyWebIO also supports outputting individual button:"
msgstr "å½“ç„¶ï¼ŒPyWebIOè¿˜æ”¯æŒå•ç‹¬çš„æŒ‰é’®æ§ä»¶:"

#: ../../guide.rst:360
#, python-format
msgid ""
"def btn_click(btn_val):\n"
"    put_text(\"You click %s button\" % btn_val)\n"
"\n"
"put_buttons(['A', 'B', 'C'], onclick=btn_click)  # a group of buttons\n"
"\n"
"put_button(\"Click me\", onclick=lambda: toast(\"Clicked\"))  # single button"
msgstr ""

#: ../../guide.rst:371
msgid ""
"In fact, all output can be bound to click events, not just buttons. You can call ``onclick()`` method after the output function (function name like "
"``put_xxx()``) call:"
msgstr "äº‹å®ä¸Šï¼Œä¸ä»…æ˜¯æŒ‰é’®ï¼Œæ‰€æœ‰çš„è¾“å‡ºéƒ½å¯ä»¥ç»‘å®šç‚¹å‡»äº‹ä»¶ã€‚ä½ å¯ä»¥åœ¨è¾“å‡ºå‡½æ•°ä¹‹åè°ƒç”¨ ``onclick()`` æ–¹æ³•æ¥ç»‘å®šç‚¹å‡»äº‹ä»¶:"

#: ../../guide.rst:374
msgid ""
"put_image('some-image.png').onclick(lambda: toast('You click an image'))  # ..doc-only\n"
"put_image('https://www.python.org/static/img/python-logo.png').onclick(lambda: toast('You click an image'))  # ..demo-only\n"
"\n"
"# set onclick in combined output\n"
"put_table([\n"
"    ['Commodity', 'Price'],\n"
"    ['Apple', put_text('5.5').onclick(lambda: toast('You click the text'))],\n"
"])"
msgstr ""

#: ../../guide.rst:387
msgid "The return value of ``onclick()`` method is the object itself so it can be used in combined output."
msgstr "``onclick()`` æ–¹æ³•çš„è¿”å›å€¼ä¸ºå¯¹è±¡æœ¬èº«ï¼Œæ‰€ä»¥å¯ä»¥ç»§ç»­ç”¨äºç»„åˆè¾“å‡ºä¸­ã€‚"

#: ../../guide.rst:392
msgid "Output Scope"
msgstr "è¾“å‡ºåŸŸScope"

#: ../../guide.rst:394
msgid ""
"PyWebIO uses the scope model to give more control to the location of content output. The output scope is a container of output content. You can "
"create a scope in somewhere and append content to it."
msgstr "PyWebIOä½¿ç”¨scopeæ¨¡å‹æ¥æ§åˆ¶å†…å®¹è¾“å‡ºçš„ä½ç½®ã€‚scopeä¸ºè¾“å‡ºå†…å®¹çš„å®¹å™¨ï¼Œä½ å¯ä»¥åˆ›å»ºä¸€ä¸ªscopeå¹¶å°†å†…å®¹è¾“å‡ºåˆ°å…¶ä¸­ã€‚"

#: ../../guide.rst:397
msgid ""
"Each output function (function name like ``put_xxx()``) will output its content to a scope, the default is \"current scope\". The \"current scope\" "
"is set by `use_scope() <pywebio.output.use_scope>`."
msgstr ""
"æ¯ä¸ªè¾“å‡ºå‡½æ•°ï¼ˆå‡½æ•°åå½¢å¦‚ `put_xxx()` ï¼‰éƒ½ä¼šå°†å†…å®¹è¾“å‡ºåˆ°ä¸€ä¸ªScopeï¼Œé»˜è®¤ä¸º\"å½“å‰Scope\"ï¼Œ\"å½“å‰Scope\"ç”± `use_scope() <pywebio.output.use_scope>` è®¾"
"ç½®ã€‚"

#: ../../guide.rst:402
msgid "**use_scope()**"
msgstr ""

#: ../../guide.rst:404
msgid "You can use `use_scope() <pywebio.output.use_scope>` to open and enter a new output scope, or enter an existing output scope:"
msgstr "å¯ä»¥ä½¿ç”¨ `use_scope() <pywebio.output.use_scope>` å¼€å¯å¹¶è¿›å…¥ä¸€ä¸ªæ–°çš„è¾“å‡ºåŸŸï¼Œæˆ–è¿›å…¥ä¸€ä¸ªå·²ç»å­˜åœ¨çš„è¾“å‡ºåŸŸ:"

#: ../../guide.rst:406
msgid ""
"with use_scope('scope1'):  # open and enter a new output: 'scope1'\n"
"    put_text('text1 in scope1')  # output text to scope1\n"
"\n"
"put_text('text in parent scope of scope1')  # output text to ROOT scope\n"
"\n"
"with use_scope('scope1'):  # enter an existing scope: 'scope1'\n"
"    put_text('text2 in scope1')  # output text to scope1"
msgstr ""
"with use_scope('scope1'):  # åˆ›å»ºå¹¶è¿›å…¥scope 'scope1'\n"
"    put_text('text1 in scope1')  # è¾“å‡ºå†…å®¹åˆ° scope1\n"
"\n"
"put_text('text in parent scope of scope1')  # è¾“å‡ºå†…å®¹åˆ° ROOT scope\n"
"\n"
"with use_scope('scope1'):  # è¿›å…¥ä¹‹å‰åˆ›å»ºçš„scope 'scope1'\n"
"    put_text('text2 in scope1')  # è¾“å‡ºå†…å®¹åˆ° scope1"

#: ../../guide.rst:418 ../../guide.rst:439
msgid "The results of the above code are as follows::"
msgstr "ä»¥ä¸Šä»£ç å°†ä¼šè¾“å‡º::"

#: ../../guide.rst:420
msgid ""
"text1 in scope1\n"
"text2 in scope1\n"
"text in parent scope of scope1"
msgstr ""

#: ../../guide.rst:424
msgid "You can use ``clear`` parameter in `use_scope() <pywebio.output.use_scope>` to clear the existing content before entering the scope:"
msgstr "`use_scope() <pywebio.output.use_scope>` è¿˜å¯ä»¥ä½¿ç”¨ `clear` å‚æ•°å°†scopeä¸­åŸæœ‰çš„å†…å®¹æ¸…ç©º:"

#: ../../guide.rst:426
msgid ""
"with use_scope('scope2'):\n"
"    put_text('create scope2')\n"
"\n"
"put_text('text in parent scope of scope2')\n"
"## ----\n"
"\n"
"with use_scope('scope2', clear=True):  # enter the existing scope and clear the previous content\n"
"    put_text('text in scope2')"
msgstr ""
"with use_scope('scope2'):\n"
"    put_text('create scope2')\n"
"\n"
"put_text('text in parent scope of scope2')\n"
"## â€”â€”\n"
"\n"
"with use_scope('scope2', clear=True):  # è¿›å…¥ä¹‹å‰åˆ›å»ºçš„scope2ï¼Œå¹¶æ¸…ç©ºåŸæœ‰å†…å®¹\n"
"    put_text('text in scope2')"

#: ../../guide.rst:441
msgid ""
"text in scope2\n"
"text in parent scope of scope2"
msgstr ""

#: ../../guide.rst:444
msgid "`use_scope() <pywebio.output.use_scope>` can also be used as decorator:"
msgstr "`use_scope() <pywebio.output.use_scope>` è¿˜å¯ä»¥ä½œä¸ºè£…é¥°å™¨æ¥ä½¿ç”¨:"

#: ../../guide.rst:446
msgid ""
"import time  # ..demo-only\n"
"from datetime import datetime\n"
"\n"
"@use_scope('time', clear=True)\n"
"def show_time():\n"
"    put_text(datetime.now())\n"
"\n"
"while 1:          # ..demo-only\n"
"   show_time()    # ..demo-only\n"
"   time.sleep(1)  # ..demo-only"
msgstr ""

#: ../../guide.rst:461
msgid ""
"When calling ``show_time()`` for the first time, a ``time`` scope will be created, and the current time will be output to it. And then every time "
"the ``show_time()`` is called, the new content will replace the previous content."
msgstr "ç¬¬ä¸€æ¬¡è°ƒç”¨ ``show_time`` æ—¶ï¼Œå°†ä¼šåˆ›å»º ``time`` è¾“å‡ºåŸŸå¹¶åœ¨å…¶ä¸­è¾“å‡ºå½“å‰æ—¶é—´ï¼Œä¹‹åæ¯æ¬¡è°ƒç”¨ ``show_time()`` ï¼Œè¾“å‡ºåŸŸéƒ½ä¼šè¢«æ–°çš„å†…å®¹è¦†ç›–ã€‚"

#: ../../guide.rst:464
msgid ""
"Scopes can be nested. At the beginning, PyWebIO applications have only one ``ROOT`` scope. You can create new scope in a scope. For example, the "
"following code will create 3 scopes:"
msgstr "Scopeæ”¯æŒåµŒå¥—ã€‚ä¼šè¯å¼€å§‹æ—¶ï¼ŒPyWebIOåº”ç”¨åªæœ‰ä¸€ä¸ª ``ROOT`` scopeã€‚ä½ å¯ä»¥åœ¨ä¸€ä¸ªscopeä¸­åˆ›å»ºæ–°çš„scopeã€‚æ¯”å¦‚ï¼Œä»¥ä¸‹ä»£ç å°†ä¼šåˆ›å»º3ä¸ªscope:"

#: ../../guide.rst:467
#, python-format
msgid ""
"with use_scope('A'):\n"
"    put_text('Text in scope A')\n"
"\n"
"    with use_scope('B'):\n"
"        put_text('Text in scope B')\n"
"\n"
"with use_scope('C'):\n"
"    put_text('Text in scope C')\n"
"\n"
"put_html(\"\"\"<style>                                          # ..demo-only\n"
"#pywebio-scope-A {border: 1px solid red;}                    # ..demo-only\n"
"#pywebio-scope-B {border: 1px solid blue;margin:2px}         # ..demo-only\n"
"#pywebio-scope-C {border: 1px solid green;margin-top:2px}    # ..demo-only\n"
"</style>\"\"\")                                                 # ..demo-only\n"
"put_text()                                                   # ..demo-only\n"
"put_buttons([('Put text to %s' % i, i) for i in ('A', 'B', 'C')], lambda s: put_text(s, scope=s))  # ..demo-only"
msgstr ""

#: ../../guide.rst:489
msgid "The above code will generate the following scope layout::"
msgstr "ä»¥ä¸Šä»£ç å°†ä¼šäº§ç”Ÿå¦‚ä¸‹Scopeå¸ƒå±€::"

#: ../../guide.rst:491
msgid ""
"â”Œâ”€ROOTâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n"
"â”‚                         â”‚\n"
"â”‚ â”Œâ”€Aâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚\n"
"â”‚ â”‚ Text in scope A     â”‚ â”‚\n"
"â”‚ â”‚ â”Œâ”€Bâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â”‚\n"
"â”‚ â”‚ â”‚ Text in scope B â”‚ â”‚ â”‚\n"
"â”‚ â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ â”‚\n"
"â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚\n"
"â”‚                         â”‚\n"
"â”‚ â”Œâ”€Câ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚\n"
"â”‚ â”‚ Text in scope C     â”‚ â”‚\n"
"â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚\n"
"â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜"
msgstr ""

#: ../../guide.rst:507
msgid "**put_scope()**"
msgstr ""

#: ../../guide.rst:509
msgid ""
"We already know that the scope is a container of output content. So can we use this container as a sub-item of a output (like, set a cell in table "
"as a container)? Yes, you can use `put_scope() <pywebio.output.put_scope>` to create a scope explicitly. The function name starts with ``put_``, "
"which means it can be pass to the functions that accept ``put_xxx()`` calls."
msgstr ""
"æˆ‘ä»¬å·²ç»çŸ¥é“scopeå®é™…ä¸Šæ˜¯è¾“å‡ºå†…å®¹çš„å®¹å™¨ï¼Œé‚£ä¹ˆæˆ‘ä»¬èƒ½å¦å°†scopeä½œä¸ºè¾“å‡ºçš„å­å…ƒç´ å‘¢ï¼ˆæ¯”å¦‚å°†scopeä½œä¸ºè¡¨æ ¼çš„ä¸€ä¸ªcellï¼‰ï¼Œç­”æ¡ˆæ˜¯è‚¯å®šçš„ã€‚ä½ å¯ä»¥ä½¿ç”¨ "
"`put_scope() <pywebio.output.put_scope>` æ¥æ˜¾å¼åˆ›å»ºä¸€ä¸ªscopeï¼Œè€Œä»å®ƒä»¥ ``put_`` å¼€å¤´çš„å‡½æ•°åå¯ä»¥çœ‹å‡ºï¼Œå®ƒä¹Ÿå¯ä»¥è¢«ä¼ é€’åˆ°ä»»ä½•å¯ä»¥æ¥å— ``put_xxx()`` è°ƒ"
"ç”¨çš„åœ°æ–¹ã€‚"

#: ../../guide.rst:514
msgid ""
"put_table([\n"
"    ['Name', 'Hobbies'],\n"
"    ['Tom', put_scope('hobby', content=put_text('Coding'))]  # hobby is initialized to coding\n"
"])\n"
"\n"
"## ----\n"
"with use_scope('hobby', clear=True):\n"
"    put_text('Movie')  # hobby is reset to Movie\n"
"\n"
"## ----\n"
"# append Music, Drama to hobby\n"
"with use_scope('hobby'):\n"
"    put_text('Music')\n"
"    put_text('Drama')\n"
"\n"
"## ----\n"
"# insert the Coding into the top of the hobby\n"
"put_markdown('**Coding**', scope='hobby', position=0)"
msgstr ""

#: ../../guide.rst:538
msgid "It is not allowed to have two scopes with the same name in the application."
msgstr ""

#: ../../guide.rst:540
msgid "**Scope control**"
msgstr "**è¾“å‡ºåŸŸæ§åˆ¶å‡½æ•°**"

#: ../../guide.rst:542
msgid ""
"In addition to `use_scope() <pywebio.output.use_scope>` and `put_scope() <pywebio.output.put_scope>`, PyWebIO also provides the following scope "
"control functions:"
msgstr "é™¤äº† `use_scope() <pywebio.output.use_scope>` å’Œ `put_scope() <pywebio.output.put_scope>` , PyWebIOè¿˜æä¾›äº†ä»¥ä¸‹scopeæ§åˆ¶å‡½æ•°ï¼š"

#: ../../guide.rst:545
msgid "`clear(scope) <pywebio.output.clear>` : Clear the contents of the scope"
msgstr "`clear(scope) <pywebio.output.clear>` : æ¸…é™¤scopeçš„å†…å®¹"

#: ../../guide.rst:546
msgid "`remove(scope) <pywebio.output.remove>` : Remove scope"
msgstr "`remove(scope) <pywebio.output.remove>` : ç§»é™¤scope"

#: ../../guide.rst:547
msgid "`scroll_to(scope) <pywebio.output.scroll_to>` : Scroll the page to the scope"
msgstr "`scroll_to(scope) <pywebio.output.scroll_to>` : å°†é¡µé¢æ»šåŠ¨åˆ°scopeå¤„"

#: ../../guide.rst:549
msgid ""
"Also, all output functions (function name like ``put_xxx()``) support a ``scope`` parameter to specify the destination scope to output, and support "
"a ``position`` parameter to specify the insert position in target scope. Refer :ref:`output module <scope_param>` for more information."
msgstr ""
"å¦å¤–ï¼Œæ‰€æœ‰çš„è¾“å‡ºå‡½æ•°è¿˜æ”¯æŒä½¿ç”¨ ``scope`` å‚æ•°æ¥æŒ‡å®šè¾“å‡ºçš„ç›®çš„scopeï¼Œä¹Ÿå¯ä½¿ç”¨ ``position`` å‚æ•°æ¥æŒ‡å®šåœ¨ç›®æ ‡scopeä¸­è¾“å‡ºçš„ä½ç½®ã€‚æ›´å¤šä¿¡æ¯å‚è§ :ref:"
"`output æ¨¡å— <scope_param>` ã€‚"

#: ../../guide.rst:554
msgid "Layout"
msgstr "å¸ƒå±€"

#: ../../guide.rst:556
msgid ""
"In general, using the output functions introduced above is enough to output what you want, but these outputs are arranged vertically. If you want "
"to create a more complex layout (such as displaying a code block on the left side of the page and an image on the right), you need to use layout "
"functions."
msgstr "é€šå¸¸ï¼Œä½¿ç”¨ä¸Šè¿°è¾“å‡ºå‡½æ•°è¶³ä»¥å®Œæˆå¤§éƒ¨åˆ†è¾“å‡ºï¼Œä½†æ˜¯è¿™äº›è¾“å‡ºä¹‹é—´å…¨éƒ½æ˜¯ç«–ç›´æ’åˆ—çš„ã€‚å¦‚æœæƒ³åˆ›å»ºæ›´å¤æ‚çš„å¸ƒå±€ï¼Œéœ€è¦ä½¿ç”¨å¸ƒå±€å‡½æ•°ã€‚"

#: ../../guide.rst:560
msgid "The ``pywebio.output`` module provides 3 layout functions, and you can create complex layouts by combining them:"
msgstr "``pywebio.output`` æ¨¡å—æä¾›äº†3ä¸ªå¸ƒå±€å‡½æ•°ï¼Œé€šè¿‡å¯¹ä»–ä»¬è¿›è¡Œç»„åˆå¯ä»¥å®Œæˆå„ç§å¤æ‚çš„å¸ƒå±€:"

#: ../../guide.rst:562
msgid "`put_row() <pywebio.output.put_row>` : Use row layout to output content. The content is arranged horizontally"
msgstr "`put_row() <pywebio.output.put_row>` : ä½¿ç”¨è¡Œå¸ƒå±€è¾“å‡ºå†…å®¹. å†…å®¹åœ¨æ°´å¹³æ–¹å‘ä¸Šæ’åˆ—"

#: ../../guide.rst:563
msgid "`put_column() <pywebio.output.put_column>` : Use column layout to output content. The content is arranged vertically"
msgstr "`put_column() <pywebio.output.put_column>` : ä½¿ç”¨åˆ—å¸ƒå±€è¾“å‡ºå†…å®¹. å†…å®¹åœ¨ç«–ç›´æ–¹å‘ä¸Šæ’åˆ—"

#: ../../guide.rst:564
msgid "`put_grid() <pywebio.output.put_grid>` : Output content using grid layout"
msgstr "`put_grid() <pywebio.output.put_grid>` : ä½¿ç”¨ç½‘æ ¼å¸ƒå±€è¾“å‡ºå†…å®¹"

#: ../../guide.rst:566
msgid "Here is an example by combining ``put_row()`` and ``put_column()``:"
msgstr "é€šè¿‡ç»„åˆ ``put_row()`` å’Œ ``put_column()`` å¯ä»¥å®ç°çµæ´»å¸ƒå±€:"

#: ../../guide.rst:568
msgid ""
"put_row([\n"
"    put_column([\n"
"        put_code('A'),\n"
"        put_row([\n"
"            put_code('B1'), None,  # None represents the space between the output\n"
"            put_code('B2'), None,\n"
"            put_code('B3'),\n"
"        ]),\n"
"        put_code('C'),\n"
"    ]), None,\n"
"    put_code('D'), None,\n"
"    put_code('E')\n"
"])"
msgstr ""

#: ../../guide.rst:591
msgid "The layout function also supports customizing the size of each part::"
msgstr "å¸ƒå±€å‡½æ•°è¿˜æ”¯æŒè‡ªå®šä¹‰å„éƒ¨åˆ†çš„å°ºå¯¸::"

#: ../../guide.rst:593
#, python-format
msgid "put_row([put_image(...), put_image(...)], size='40% 60%')  # The ratio of the width of two images is 2:3"
msgstr "put_row([put_image(â€¦), put_image(â€¦)], size='40% 60%')  # å·¦å³ä¸¤å›¾å®½åº¦æ¯”2:3"

#: ../../guide.rst:595
msgid "For more information, please refer to the :ref:`layout functions documentation <style_and_layout>`."
msgstr "æ›´å¤šå¸ƒå±€å‡½æ•°çš„ç”¨æ³•åŠä»£ç ç¤ºä¾‹è¯·æŸ¥é˜… :ref:`å¸ƒå±€å‡½æ•°æ–‡æ¡£ <style_and_layout>` ."

#: ../../guide.rst:600
msgid "Style"
msgstr "æ ·å¼"

#: ../../guide.rst:602
msgid ""
"If you are familiar with `CSS <https://en.wikipedia.org/wiki/CSS>`_ styles, you can use the ``style()`` method of output return to set a custom "
"style for the output."
msgstr ""
"å¦‚æœä½ ç†Ÿæ‚‰ `CSSæ ·å¼ <https://www.google.com/search?q=CSS%E6%A0%B7%E5%BC%8F>`_ ï¼Œä½ è¿˜å¯ä»¥åœ¨è¾“å‡ºå‡½æ•°åè°ƒç”¨ ``style()`` æ–¹æ³•ç»™è¾“å‡ºè®¾å®šè‡ªå®šä¹‰æ ·å¼ã€‚"

#: ../../guide.rst:605
msgid "You can set the CSS style for a single ``put_xxx()`` output:"
msgstr "å¯ä»¥ç»™å•ä¸ªçš„ ``put_xxx()`` è¾“å‡ºè®¾å®šCSSæ ·å¼ï¼Œä¹Ÿå¯ä»¥é…åˆç»„åˆè¾“å‡ºä½¿ç”¨:"

#: ../../guide.rst:607
msgid ""
"put_text('hello').style('color: red; font-size: 20px')\n"
"\n"
"## ----\n"
"# in combined output\n"
"put_row([\n"
"    put_text('hello').style('color: red'),\n"
"    put_markdown('markdown')\n"
"]).style('margin-top: 20px')"
msgstr ""

#: ../../guide.rst:620
msgid "The return value of ``style()`` method is the object itself so it can be used in combined output."
msgstr "``style()`` æ–¹æ³•çš„è¿”å›å€¼ä¸ºå¯¹è±¡æœ¬èº«ï¼Œæ‰€ä»¥å¯ä»¥ç»§ç»­ç”¨äºç»„åˆè¾“å‡ºä¸­ã€‚"

#: ../../guide.rst:625
msgid "Run application"
msgstr ""

#: ../../guide.rst:627
msgid ""
"In PyWebIO, there are two modes to run PyWebIO applications: running as a script and using `pywebio.start_server() <pywebio.platform.tornado."
"start_server>` or `pywebio.platform.path_deploy() <pywebio.platform.path_deploy>` to run as a web service."
msgstr ""
"åœ¨PyWebIOä¸­ï¼Œæœ‰ä¸¤ç§æ–¹å¼ç”¨æ¥è¿è¡ŒPyWebIOåº”ç”¨ï¼šä½œä¸ºè„šæœ¬è¿è¡Œå’Œä½¿ç”¨ `pywebio.start_server() <pywebio.platform.tornado.start_server>` æˆ– `pywebio."
"platform.path_deploy() <pywebio.platform.path_deploy>` æ¥ä½œä¸ºWebæœåŠ¡è¿è¡Œã€‚"

#: ../../guide.rst:632
msgid "Overview"
msgstr ""

#: ../../guide.rst:636 ../../guide.rst:701
msgid "**Server mode**"
msgstr "**Serveræ¨¡å¼**"

#: ../../guide.rst:638
msgid ""
"In server mode, PyWebIO will start a web server to continuously provide services. When the user accesses the service address, PyWebIO will open a "
"new session and run PyWebIO application in it."
msgstr "åœ¨Serveræ¨¡å¼ä¸‹ï¼ŒPyWebIOä¼šå¯åŠ¨ä¸€ä¸ªWebæœåŠ¡æ¥æŒç»­æ€§åœ°æä¾›æœåŠ¡ã€‚å½“ç”¨æˆ·è®¿é—®æœåŠ¡åœ°å€æ—¶ï¼ŒPyWebIOä¼šå¼€å¯ä¸€ä¸ªæ–°ä¼šè¯å¹¶è¿è¡ŒPyWebIOåº”ç”¨ã€‚"

#: ../../guide.rst:641
msgid "`start_server() <pywebio.platform.tornado.start_server>` is the most common way to start a web server to serve given PyWebIO applications::"
msgstr "å°†PyWebIOåº”ç”¨éƒ¨ç½²ä¸ºwebæœåŠ¡çš„æœ€å¸¸ç”¨æ–¹å¼æ˜¯ä½¿ç”¨ `start_server() <pywebio.platform.tornado.start_server>` ::"

#: ../../guide.rst:644
msgid ""
"from pywebio import *\n"
"\n"
"def main():  # PyWebIO application function\n"
"    name = input.input(\"what's your name\")\n"
"    output.put_text(\"hello\", name)\n"
"\n"
"start_server(main, port=8080, debug=True)"
msgstr ""

#: ../../guide.rst:652
msgid "Now head over to http://127.0.0.1:8080/, and you should see your hello greeting."
msgstr "ç°åœ¨ï¼Œåœ¨ http://127.0.0.1:8080/ é¡µé¢å°±ä¼šçœ‹åˆ°æ¬¢è¿é¡µé¢äº†ã€‚"

#: ../../guide.rst:654
msgid "By using ``debug=True`` to enable debug mode, the server will automatically reload if code changes."
msgstr "ä½¿ç”¨ ``debug=True`` æ¥å¼€å¯debugæ¨¡å¼ï¼Œè¿™æ—¶serverä¼šåœ¨æ£€æµ‹åˆ°ä»£ç å‘ç”Ÿæ›´æ”¹åè¿›è¡Œé‡å¯ã€‚"

#: ../../guide.rst:656
msgid ""
"The `start_server() <pywebio.platform.tornado.start_server>` provide a remote access support, when enabled (by passing `remote_access=True` to "
"`start_server()`), you will get a public, shareable address for the current application, others can access your application in their browser via "
"this address. Because the processing happens on your device (as long as your device stays on!), you don't have to worry about any dependencies. "
"Using remote access makes it easy to temporarily share the application with others."
msgstr ""
"`start_server() <pywebio.platform.tornado.start_server>` æä¾›äº†å¯¹è¿œç¨‹è®¿é—®çš„æ”¯æŒï¼Œå½“å¼€å¯è¿œç¨‹è®¿é—®åï¼ˆé€šè¿‡åœ¨ `start_server()` ä¸­ä¼ å…¥ "
"`remote_access=True` å¼€å¯ ï¼‰ï¼Œä½ å°†ä¼šå¾—åˆ°ä¸€ä¸ªç”¨äºè®¿é—®å½“å‰åº”ç”¨çš„ä¸´æ—¶çš„å…¬ç½‘è®¿é—®åœ°å€ï¼Œå…¶ä»–ä»»ä½•äººéƒ½å¯ä»¥ä½¿ç”¨æ­¤åœ°å€è®¿é—®ä½ çš„åº”ç”¨ã€‚è¿œç¨‹æ¥å…¥å¯ä»¥å¾ˆæ–¹ä¾¿åœ°å°†åº”ç”¨"
"ä¸´æ—¶åˆ†äº«ç»™å…¶ä»–äººã€‚"

#: ../../guide.rst:662
msgid ""
"Another way to deploy PyWebIO application as web service is using `path_deploy() <pywebio.platform.path_deploy>`. `path_deploy() <pywebio.platform."
"path_deploy>` is used to deploy the PyWebIO applications from a directory. Just define PyWebIO applications in python files under this directory, "
"and you can access them via the path in the URL. Refer to :ref:`platform module <dir_deploy>` for more information."
msgstr ""
"å°†PyWebIOåº”ç”¨éƒ¨ç½²ä¸ºwebæœåŠ¡çš„å¦ä¸€ç§æ–¹å¼æ˜¯ä½¿ç”¨ `path_deploy() <pywebio.platform.path_deploy>` ã€‚`path_deploy() <pywebio.platform.path_deploy>` å¯ä»¥ä»"
"ä¸€ä¸ªç›®å½•ä¸­éƒ¨ç½²PyWebIOåº”ç”¨ï¼Œåªéœ€è¦åœ¨è¯¥ç›®å½•ä¸‹çš„pythonæ–‡ä»¶ä¸­å®šä¹‰PyWebIOåº”ç”¨ï¼Œå°±å¯ä»¥é€šè¿‡URLä¸­çš„è·¯å¾„æ¥è®¿é—®è¿™äº›åº”ç”¨äº†ã€‚"

#: ../../guide.rst:669
msgid ""
"Note that in Server mode, all functions from ``pywebio.input``, ``pywebio.output`` and ``pywebio.session`` modules can only be called in the "
"context of PyWebIO application functions. For example, the following code is **not allowed**::"
msgstr ""
"æ³¨æ„ï¼Œåœ¨Serveræ¨¡å¼ä¸‹ï¼Œ ``pywebio.input`` ã€ ``pywebio.output`` å’Œ ``pywebio.session`` æ¨¡å—å†…çš„å‡½æ•°ä»…èƒ½åœ¨ä»»åŠ¡å‡½æ•°ä¸Šä¸‹æ–‡ä¸­è¿›è¡Œè°ƒç”¨ã€‚æ¯”å¦‚å¦‚ä¸‹è°ƒç”¨æ˜¯ **"
"ä¸è¢«å…è®¸çš„** ::"

#: ../../guide.rst:672
msgid ""
"import pywebio\n"
"from pywebio.input import input\n"
"\n"
"port = input('Input port number:')   # âŒ error\n"
"pywebio.start_server(my_task_func, port=int(port))"
msgstr ""

#: ../../guide.rst:679 ../../guide.rst:696
msgid "**Script mode**"
msgstr "**Scriptæ¨¡å¼**"

#: ../../guide.rst:681
msgid "If you never call ``start_server()`` or ``path_deploy()`` in your code, then you are running PyWebIO application as script mode."
msgstr "å¦‚æœä½ åœ¨ä»£ç ä¸­æ²¡æœ‰è°ƒç”¨ ``start_server()`` æˆ– ``path_deploy()`` å‡½æ•°ï¼Œé‚£ä¹ˆä½ å°±æ˜¯ä»¥è„šæœ¬æ¨¡å¼åœ¨è¿è¡ŒPyWebIOåº”ç”¨ã€‚"

#: ../../guide.rst:683
msgid ""
"In script mode, a web browser page will be open automatically when running to the first call to PyWebIO interactive functions, and all subsequent "
"PyWebIO interactions will take place on this page. When the script exit, the page will be inactive."
msgstr ""
"åœ¨è„šæœ¬æ¨¡å¼ä¸­ï¼Œå½“é¦–æ¬¡è¿è¡Œåˆ°å¯¹PyWebIOäº¤äº’å‡½æ•°çš„è°ƒç”¨æ—¶ï¼Œä¼šè‡ªåŠ¨æ‰“å¼€æµè§ˆå™¨çš„ä¸€ä¸ªé¡µé¢ï¼Œåç»­çš„PyWebIOäº¤äº’éƒ½ä¼šåœ¨è¿™ä¸ªé¡µé¢ä¸Šè¿›è¡Œã€‚å½“è„šæœ¬è¿è¡Œç»“æŸï¼Œè¿™ä¸ªé¡µé¢ä¹Ÿå°†"
"ä¸å†æœ‰æ•ˆã€‚"

#: ../../guide.rst:686
msgid ""
"If the user closes the browser before the script exiting, then subsequent calls to PyWebIO's interactive functions will cause a `SessionException "
"<pywebio.exceptions.SessionException>` exception."
msgstr ""
"å¦‚æœç”¨æˆ·åœ¨è„šæœ¬ç»“æŸè¿è¡Œä¹‹å‰å…³é—­äº†æµè§ˆå™¨ï¼Œé‚£ä¹ˆä¹‹åä¼šè¯å†…å¯¹äºPyWebIOäº¤äº’å‡½æ•°çš„è°ƒç”¨å°†ä¼šå¼•å‘ä¸€ä¸ª `SessionException <pywebio.exceptions."
"SessionException>` å¼‚å¸¸ã€‚"

#: ../../guide.rst:692
msgid "Concurrent"
msgstr "å¹¶å‘"

#: ../../guide.rst:694
msgid "PyWebIO can be used in a multi-threading environment."
msgstr "PyWebIO æ”¯æŒåœ¨å¤šçº¿ç¨‹ç¯å¢ƒä¸­ä½¿ç”¨ã€‚"

#: ../../guide.rst:698
msgid ""
"In script mode, you can freely start new thread and call PyWebIO interactive functions in it. When all `non-daemonic <https://docs.python.org/3/"
"library/threading.html#thread-objects>`_ threads finish running, the script exits."
msgstr ""
"åœ¨ Scriptæ¨¡å¼ä¸‹ï¼Œä½ å¯ä»¥è‡ªç”±åœ°å¯åŠ¨çº¿ç¨‹ï¼Œå¹¶åœ¨å…¶ä¸­è°ƒç”¨PyWebIOçš„äº¤äº’å‡½æ•°ã€‚å½“æ‰€æœ‰é `Daemonçº¿ç¨‹ <https://docs.python.org/3/library/threading.html#thread-"
"objects>`_ è¿è¡Œç»“æŸåï¼Œè„šæœ¬é€€å‡ºã€‚"

#: ../../guide.rst:703
msgid ""
"In server mode, if you need to use PyWebIO interactive functions in new thread, you need to use `pywebio.session.register_thread(thread) <pywebio."
"session.register_thread>` to register the new thread (so that PyWebIO can know which session the thread belongs to). If the PyWebIO interactive "
"function is not used in the new thread, no registration is required. Threads that are not registered with `register_thread(thread) <pywebio.session."
"register_thread>` calling PyWebIO's interactive functions will cause `SessionNotFoundException <pywebio.exceptions.SessionNotFoundException>`."
msgstr ""
"Serveræ¨¡å¼ä¸‹ï¼Œå¦‚æœéœ€è¦åœ¨æ–°åˆ›å»ºçš„çº¿ç¨‹ä¸­ä½¿ç”¨PyWebIOçš„äº¤äº’å‡½æ•°ï¼Œéœ€è¦æ‰‹åŠ¨è°ƒç”¨ `register_thread(thread) <pywebio.session.register_thread>` å¯¹æ–°è¿›ç¨‹è¿›è¡Œæ³¨"
"å†Œï¼ˆè¿™æ ·PyWebIOæ‰èƒ½çŸ¥é“æ–°åˆ›å»ºçš„çº¿ç¨‹å±äºå“ªä¸ªä¼šè¯ï¼‰ã€‚å¦‚æœæ–°åˆ›å»ºçš„çº¿ç¨‹ä¸­æ²¡æœ‰ä½¿ç”¨åˆ°PyWebIOçš„äº¤äº’å‡½æ•°ï¼Œåˆ™æ— éœ€æ³¨å†Œã€‚æ²¡æœ‰ä½¿ç”¨ `register_thread(thread) "
"<pywebio.session.register_thread>` æ³¨å†Œçš„çº¿ç¨‹ä¸å—ä¼šè¯ç®¡ç†ï¼Œå…¶è°ƒç”¨PyWebIOçš„äº¤äº’å‡½æ•°å°†ä¼šäº§ç”Ÿ `SessionNotFoundException <pywebio.exceptions."
"SessionNotFoundException>` å¼‚å¸¸ã€‚"

#: ../../guide.rst:710
msgid "Example of using multi-threading in Server mode::"
msgstr "Serveræ¨¡å¼ä¸‹å¤šçº¿ç¨‹çš„ä½¿ç”¨ç¤ºä¾‹::"

#: ../../guide.rst:712
msgid ""
"def show_time():\n"
"    while True:\n"
"        with use_scope(name='time', clear=True):\n"
"            put_text(datetime.datetime.now())\n"
"            time.sleep(1)\n"
"\n"
"def app():\n"
"    t = threading.Thread(target=show_time)\n"
"    register_thread(t)\n"
"    put_markdown('## Clock')\n"
"    t.start()  # run `show_time()` in background\n"
"\n"
"    # âŒ this thread will cause `SessionNotFoundException`\n"
"    threading.Thread(target=show_time).start()\n"
"\n"
"    put_text('Background task started.')\n"
"\n"
"\n"
"start_server(app, port=8080, debug=True)"
msgstr ""

#: ../../guide.rst:736
msgid "Close of session"
msgstr "ä¼šè¯çš„ç»“æŸ"

#: ../../guide.rst:738
msgid ""
"When user close the browser page, the session will be closed. After the browser page is closed, PyWebIO input function calls that have not yet "
"returned in the current session will cause `SessionClosedException <pywebio.exceptions.SessionClosedException>`, and subsequent calls to PyWebIO "
"interactive functions will cause `SessionNotFoundException <pywebio.exceptions.SessionNotFoundException>` or `SessionClosedException <pywebio."
"exceptions.SessionClosedException>`."
msgstr ""
"å½“ç”¨æˆ·å…³é—­æµè§ˆå™¨é¡µé¢æ—¶ï¼Œä¸ä¹‹ç›¸åº”çš„ä¼šè¯ä¹Ÿå°†è¢«å…³é—­ã€‚ä¼šè¯å…³é—­åï¼Œåº”ç”¨ä¸­æœªè¿”å›çš„PyWebIOè¾“å…¥å‡½æ•°çš„è°ƒç”¨å°†ä¼šæŠ›å‡º `SessionClosedException <pywebio."
"exceptions.SessionClosedException>` å¼‚å¸¸ï¼Œåç»­å¯¹PyWebIOäº¤äº’å‡½æ•°çš„è°ƒç”¨å°†ä¼šå¼•å‘ `SessionNotFoundException <pywebio.exceptions."
"SessionNotFoundException>` æˆ– `SessionClosedException <pywebio.exceptions.SessionClosedException>` å¼‚å¸¸ã€‚"

#: ../../guide.rst:743
msgid "In most cases, you don't need to catch those exceptions, because let those exceptions to abort the running is the right way to exit."
msgstr "å¤§éƒ¨åˆ†æƒ…å†µä¸‹ï¼Œä½ ä¸éœ€è¦æ•è·è¿™äº›å¼‚å¸¸ï¼Œè®©è¿™äº›å¼‚å¸¸æ¥ç»ˆæ­¢ä»£ç çš„æ‰§è¡Œé€šå¸¸æ˜¯æ¯”è¾ƒåˆé€‚çš„ã€‚"

#: ../../guide.rst:745
msgid ""
"You can use `pywebio.session.defer_call(func) <pywebio.session.defer_call>` to set the function to be called when the session closes. "
"`defer_call(func) <pywebio.session.defer_call>` can be used for resource cleaning. You can call `defer_call(func) <pywebio.session.defer_call>` "
"multiple times in the session, and the set functions will be executed sequentially after the session closes."
msgstr ""
"å¯ä»¥ä½¿ç”¨ `pywebio.session.defer_call(func) <pywebio.session.defer_call>` æ¥è®¾ç½®ä¼šè¯ç»“æŸæ—¶éœ€è¦è°ƒç”¨çš„å‡½æ•°ã€‚æ— è®ºæ˜¯å› ä¸ºç”¨æˆ·ä¸»åŠ¨å…³é—­é¡µé¢è¿˜æ˜¯ä»»åŠ¡ç»“æŸä½¿å¾—"
"ä¼šè¯å…³é—­ï¼Œè®¾ç½®çš„å‡½æ•°éƒ½ä¼šè¢«æ‰§è¡Œã€‚`defer_call(func) <pywebio.session.defer_call>` å¯ä»¥ç”¨äºèµ„æºæ¸…ç†ç­‰å·¥ä½œã€‚åœ¨ä¼šè¯ä¸­å¯ä»¥å¤šæ¬¡è°ƒç”¨ `defer_call() <pywebio."
"session.defer_call>` ,ä¼šè¯ç»“æŸåå°†ä¼šé¡ºåºæ‰§è¡Œè®¾ç½®çš„å‡½æ•°ã€‚"

#: ../../guide.rst:751
msgid "More about PyWebIO"
msgstr ""

#: ../../guide.rst:752
msgid ""
"By now, you already get the most important features of PyWebIO and can start to write awesome PyWebIO applications. However, there are some other "
"useful features we don't cover in the above. Here we just make a briefly explain about them. When you need them in your application, you can refer "
"to their document."
msgstr ""
"ç›®å‰ä¸ºæ­¢ï¼Œä½ å·²ç»äº†è§£äº†PyWebIOä¸­æœ€é‡è¦çš„ç‰¹æ€§ï¼Œå¹¶ä¸”å¯ä»¥å¼€å§‹ç¼–å†™PyWebIOåº”ç”¨äº†ã€‚ç„¶è€Œï¼Œæœ‰äº›åŠŸèƒ½å‰é¢æˆ‘ä»¬å¹¶æ²¡æœ‰è¦†ç›–åˆ°ï¼Œè¿™é‡Œæä¾›äº†å¯¹å‰©ä½™ç‰¹æ€§çš„ä¸€äº›ç®€çŸ­ä»‹ç»ï¼Œ"
"å¦‚æœä½ åœ¨åº”ç”¨ç¼–å†™è¿‡ç¨‹ä¸­éœ€è¦ç”¨åˆ°è¿™é‡Œçš„æŸä¸ªç‰¹æ€§ï¼Œä½ å¯ä»¥æŸ¥é˜…å¯¹åº”çš„è¯¦ç»†æ–‡æ¡£ã€‚"

#: ../../guide.rst:756
msgid "Also, :doc:`here </cookbook>` is a cookbook where you can find some useful code snippets for your PyWebIO application."
msgstr "å¦å¤–ï¼Œä½ å¯ä»¥åœ¨ :doc:`cookbook </cookbook>` é¡µé¢æ‰¾åˆ°ä¸€äº›å¯¹äºç¼–å†™PyWebIOåº”ç”¨å¾ˆæœ‰å¸®åŠ©çš„ä»£ç ç‰‡æ®µã€‚"

#: ../../guide.rst:759
msgid "``session`` module"
msgstr "``session`` æ¨¡å—"

#: ../../guide.rst:760
msgid "The :doc:`pywebio.session </session>` module give you more control to session."
msgstr ":doc:`pywebio.session </session>` æ¨¡å—æä¾›äº†å¯¹ä¼šè¯çš„æ›´å¤šæ§åˆ¶ ã€‚"

#: ../../guide.rst:762
msgid "Use `set_env() <pywebio.session.set_env>` to configure the title, page appearance, input panel and so on for current session."
msgstr "ä½¿ç”¨ `set_env() <pywebio.session.set_env>` æ¥ä¸ºå½“å‰ä¼šè¯è®¾ç½®æ ‡é¢˜ã€é¡µé¢å¤–è§‚ã€è¾“å…¥æ ç­‰å†…å®¹ã€‚"

#: ../../guide.rst:764
msgid ""
"The `info <pywebio.session.info>` object provides a lot information about the current session, such as the user IP address, user language and user "
"browser information."
msgstr "`info <pywebio.session.info>` å¯¹è±¡æä¾›äº†å…³äºå½“å‰ç»˜ç”»çš„å¾ˆå¤šä¿¡æ¯ï¼Œæ¯”å¦‚ç”¨æˆ·IPåœ°å€ã€ç”¨æˆ·è¯­è¨€ã€ç”¨æˆ·æµè§ˆå™¨ä¿¡æ¯ç­‰ã€‚"

#: ../../guide.rst:767
msgid "`local <pywebio.session.local>` is a session-local storage, it used to save data whose values are session specific."
msgstr "`local <pywebio.session.local>` æ˜¯ä¸€ä¸ªsession-localçš„å­˜å‚¨å¯¹è±¡, ç”¨äºå­˜å‚¨ä¼šè¯ç‹¬ç«‹çš„æ•°æ®ã€‚"

#: ../../guide.rst:769
msgid ""
"`run_js() <pywebio.session.run_js>` let you execute JavaScript code in user's browser, and `eval_js() <pywebio.session.eval_js>` let you execute "
"JavaScript expression and get the value of it."
msgstr ""
"`run_js() <pywebio.session.run_js>` è®©ä½ åœ¨ç”¨æˆ·æµè§ˆå™¨ä¸­æ‰§è¡ŒJavaScriptä»£ç , `eval_js() <pywebio.session.eval_js>` è®©ä½ æ‰§è¡Œå¹¶è·å–JavaScriptè¡¨è¾¾å¼çš„å€¼ã€‚"

#: ../../guide.rst:773
msgid "``pin`` module"
msgstr "``pin`` æ¨¡å—"

#: ../../guide.rst:774
msgid ""
"As you already know, the input function of PyWebIO is blocking and the input form will be destroyed after successful submission. In some cases, you "
"may want to make the input form not disappear after submission, and can continue to receive input. So PyWebIO provides the :doc:`pywebio.pin </"
"pin>` module to achieve persistent input by pinning input widgets to the page."
msgstr ""
"ä½ å·²ç»çŸ¥é“ï¼ŒPyWebIOçš„è¾“å…¥å‡½æ•°æ˜¯é˜»å¡å¼çš„ï¼Œå¹¶ä¸”è¾“å…¥è¡¨å•ä¼šåœ¨æˆåŠŸæäº¤åæ¶ˆå¤±ã€‚åœ¨æŸäº›æ—¶å€™ï¼Œä½ å¯èƒ½æƒ³è¦è¾“å…¥è¡¨å•ä¸€ç›´æ˜¾ç¤ºå¹¶å¯ä»¥æŒç»­æ€§æ¥æ”¶ç”¨æˆ·è¾“å…¥ï¼Œè¿™æ—¶ä½ å¯ä»¥"
"ä½¿ç”¨ :doc:`pywebio.pin </pin>` æ¨¡å—ã€‚"

#: ../../guide.rst:779
msgid "``platform`` module"
msgstr "``platform`` æ¨¡å—"

#: ../../guide.rst:781
msgid "The :doc:`pywebio.platform </platform>` module provides support for deploying PyWebIO applications in different ways."
msgstr ":doc:`pywebio.platform </platform>` æ¨¡å—æä¾›äº†å°†PyWebIOåº”ç”¨ä»¥å¤šç§æ–¹å¼éƒ¨ç½²çš„æ”¯æŒã€‚"

#: ../../guide.rst:783
msgid ""
"There are two protocols (WebSocket and HTTP) can be used in server to communicates with the browser. The WebSocket is used by default. If you want "
"to use HTTP protocol, you can choose other ``start_server()`` functions in this module."
msgstr ""
"PyWebIOçš„æœåŠ¡ç«¯ä¸æµè§ˆå™¨å¯ä»¥é€šè¿‡ä¸¤ç§åè®®(WebSocket å’Œ HTTP åè®®)è¿›è¡Œé€šä¿¡ï¼Œé»˜è®¤ä½¿ç”¨WebSocketåè®®ï¼Œå¦‚æœä½ æƒ³ä½¿ç”¨HTTPåè®®ï¼Œä½ å¯ä»¥é€‰æ‹©æœ¬æ¨¡å—ä¸­çš„å…¶ä»– "
"``start_server()`` å‡½æ•°ã€‚"

#: ../../guide.rst:786
msgid ""
"You might want to set some web page related configuration (such as SEO information, js and css injection) for your PyWebIO application, `pywebio."
"config() <pywebio.config>` can be helpful."
msgstr "å¦‚æœè¦ä¸ºPyWebIOåº”ç”¨è®¾ç½®ä¸€äº›ç½‘é¡µç›¸å…³çš„é…ç½®ï¼Œå¯ä»¥å°è¯•ä½¿ç”¨ `pywebio.config() <pywebio.config>` ã€‚"

#: ../../guide.rst:790
msgid "Advanced features"
msgstr "é«˜çº§ç‰¹æ€§"

#: ../../guide.rst:792
msgid ""
"The PyWebIO application can be integrated into an existing Python web project, the PyWebIO application and the web project share a web framework. "
"Refer to :ref:`Advanced Topic: Integration with Web Framework <integration_web_framework>` for more information."
msgstr ""
"å¯ä»¥å°†PyWebIOåº”ç”¨æ•´åˆåˆ°ç°å­˜çš„Python Webé¡¹ç›®ä¸­ï¼ŒPyWebIOåº”ç”¨å’Œwebé¡¹ç›®ä½¿ç”¨ä¸€ä¸ªwebæ¡†æ¶ã€‚è¯¦ç»†ä¿¡æ¯å‚è§ :ref:`Advanced Topic: Integration with Web "
"Framework <integration_web_framework>` ã€‚"

#: ../../guide.rst:796
msgid ""
"PyWebIO also provides support for coroutine-based sessions. Refer to :ref:`Advanced Topic: Coroutine-based session <coroutine_based_session>` for "
"more information."
msgstr "PyWebIOè¿˜æ”¯æŒåŸºäºåç¨‹çš„ä¼šè¯ã€‚å…·ä½“å‚è§ :ref:`Advanced Topic: Coroutine-based session <coroutine_based_session>` ã€‚"

#: ../../guide.rst:799
msgid ""
"If you try to bundles your PyWebIO application into a stand-alone executable file, to make users can run the application without installing a "
"Python interpreter or any modules, you might want to refer to :ref:`Libraries support: Build stand-alone App <stand_alone_app>`"
msgstr ""
"å¦‚æœä½ æƒ³è¦å°†PyWebIOåº”ç”¨æ‰“åŒ…åˆ°ä¸€ä¸ªå•ç‹¬çš„å¯æ‰§è¡Œæ–‡ä»¶é‡Œé¢ï¼Œä»è€Œä½¿ç”¨æˆ·å¯ä»¥åœ¨æ²¡æœ‰å®‰è£…pythonè§£é‡Šå™¨çš„æƒ…å†µä¸‹è¿è¡Œåº”ç”¨ï¼Œä½ å¯ä»¥å‚è€ƒ :ref:`Build stand-alone App "
"<stand_alone_app>`"

#: ../../guide.rst:802
msgid ""
"If you want to make some data visualization in your PyWebIO application, you can't miss :ref:`Libraries support: Data visualization <visualization>`"
msgstr "å¦‚æœä½ æƒ³åœ¨PyWebIOåº”ç”¨ä¸­è¿›è¡Œä¸€äº›æ•°æ®å¯è§†åŒ–ï¼Œå¯ä»¥å‚è€ƒ :ref:`Data visualization <visualization>`"

#: ../../guide.rst:805
msgid "Last but not least"
msgstr ""

#: ../../guide.rst:807
msgid "This is basically all features of PyWebIO, you can continue to read the rest of the documents, or start writing your PyWebIO applications now."
msgstr "ä»¥ä¸ŠåŸºæœ¬å°±æ˜¯PyWebIOçš„å…¨éƒ¨åŠŸèƒ½äº†ï¼Œä½ å¯ä»¥ç»§ç»­é˜…è¯»æ¥ä¸‹æ¥çš„æ–‡æ¡£ï¼Œæˆ–è€…ç«‹å³å¼€å§‹PyWebIOåº”ç”¨çš„ç¼–å†™äº†ã€‚"

#: ../../guide.rst:809
msgid ""
"Finally, please allow me to provide one more suggestion. When you encounter a design problem when using PyWebIO, you can ask yourself a question: "
"What would I do if it is in a terminal program? If you already have the answer, it can be done in the same way with PyWebIO. If the problem "
"persists or the solution is not good enough, you can consider the :ref:`callback mechanism <callback>` or  :doc:`pin <./pin>` module."
msgstr ""
"æœ€åå†æä¾›ä¸€æ¡å»ºè®®ï¼Œå½“ä½ åœ¨ä½¿ç”¨PyWebIOé‡åˆ°è®¾è®¡ä¸Šçš„é—®é¢˜æ—¶ï¼Œå¯ä»¥é—®ä¸€ä¸‹è‡ªå·±ï¼šå¦‚æœåœ¨æ˜¯åœ¨ç»ˆç«¯ç¨‹åºä¸­æˆ‘ä¼šæ€ä¹ˆåšï¼Ÿå¦‚æœä½ å·²ç»æœ‰ç­”æ¡ˆäº†ï¼Œé‚£ä¹ˆåœ¨PyWebIOä¸­ä¸€æ ·å¯ä»¥"
"ä½¿ç”¨è¿™æ ·çš„æ–¹å¼å®Œæˆã€‚å¦‚æœé—®é¢˜ä¾ç„¶å­˜åœ¨æˆ–è€…è§‰å¾—è§£å†³æ–¹æ¡ˆä¸å¤Ÿå¥½ï¼Œä½ å¯ä»¥è€ƒè™‘ä½¿ç”¨ :ref:`å›è°ƒæœºåˆ¶ <callback>` æˆ– :doc:`pin <./pin>` æ¨¡å—ã€‚"

#: ../../guide.rst:814
msgid "OK, Have fun with PyWebIO!"
msgstr ""

#~ msgid ""
#~ "In the :ref:`Hello, world <hello_word>` section, we already know that PyWebIO supports two modes: running as a script and using `start_server() "
#~ "<pywebio.platform.tornado.start_server>` to run as a web service."
#~ msgstr ""
#~ "åœ¨ :ref:`Hello, world <hello_word>` ä¸€èŠ‚ä¸­ï¼Œå·²ç»çŸ¥é“ï¼ŒPyWebIOæ”¯æŒåœ¨æ™®é€šçš„è„šæœ¬ä¸­è°ƒç”¨å’Œä½¿ç”¨ `start_server() <pywebio.platform.tornado."
#~ "start_server>` å¯åŠ¨ä¸€ä¸ªWebæœåŠ¡ä¸¤ç§æ¨¡å¼ã€‚"

#~ msgid ""
#~ "Other output functions that accept ``put_xxx()`` calls as parameters are `put_collapse() <pywebio.output.put_collapse>`, `put_scrollable() "
#~ "<pywebio.output.put_scrollable>`, `put_row() <pywebio.output.put_row>`, etc. In addition, you can use `put_widget() <pywebio.output.put_widget>` "
#~ "to make your own output widgets that can accept ``put_xxx()`` calls. For more information, please refer to corresponding function documentation."
#~ msgstr ""
#~ "å…¶ä»–æ¥å— ``put_xxx()`` è°ƒç”¨ä½œä¸ºå‚æ•°çš„è¾“å‡ºå‡½æ•°è¿˜æœ‰ `put_collapse() <pywebio.output.put_collapse>` ã€ `put_scrollable() <pywebio.output."
#~ "put_scrollable>` ã€`put_row() <pywebio.output.put_row>` ç­‰ï¼Œæ­¤å¤–ï¼Œè¿˜å¯ä»¥é€šè¿‡ `put_widget() <pywebio.output.put_widget>` è‡ªå®šä¹‰å¯æ¥æ”¶ "
#~ "``put_xxx()`` è°ƒç”¨çš„è¾“å‡ºç»„ä»¶ï¼Œå…·ä½“ç”¨æ³•è¯·å‚è€ƒå‡½æ•°æ–‡æ¡£ã€‚"

#~ msgid ""
#~ "In general, using the various output functions introduced above is enough to output what you want, but these outputs are arranged vertically. If "
#~ "you want to make a more complex layout (such as displaying a code block on the left side of the page and an image on the right), you need to use "
#~ "layout functions."
#~ msgstr ""
#~ "ä¸€èˆ¬æƒ…å†µä¸‹ï¼Œä½¿ç”¨ä¸Šæ–‡ä»‹ç»çš„å„ç§è¾“å‡ºå‡½æ•°è¶³ä»¥å®Œæˆå„ç§å†…å®¹çš„å±•ç¤ºï¼Œä½†ç›´æ¥è°ƒç”¨è¾“å‡ºå‡½æ•°äº§ç”Ÿçš„è¾“å‡ºä¹‹é—´éƒ½æ˜¯ç«–ç›´æ’åˆ—çš„ï¼Œå¦‚æœæƒ³å®ç°æ›´å¤æ‚çš„å¸ƒå±€ï¼ˆæ¯”å¦‚åœ¨é¡µé¢"
#~ "å·¦ä¾§æ˜¾ç¤ºä¸€ä¸ªä»£ç å—ï¼Œåœ¨å³ä¾§æ˜¾ç¤ºä¸€ä¸ªå›¾åƒï¼‰ï¼Œå°±éœ€è¦å€ŸåŠ©å¸ƒå±€å‡½æ•°ã€‚"

#~ msgid "Need to add a ``RequestHandler`` to Tornado application::"
#~ msgstr "éœ€è¦åœ¨Tornadoåº”ç”¨ä¸­å¼•å…¥ä¸€ä¸ª ``RequestHandler`` ::"

#~ msgid "One route need to be added to communicate with the browser through HTTP::"
#~ msgstr "éœ€è¦æ·»åŠ ä¸€ä¸ªPyWebIOç›¸å…³çš„è·¯ç”±ï¼Œç”¨æ¥å’Œæµè§ˆå™¨è¿›è¡ŒHttpé€šè®¯::"

#~ msgid "Need to add a route in ``urls.py``::"
#~ msgstr "åœ¨djangoçš„è·¯ç”±é…ç½®æ–‡ä»¶ ``urls.py`` ä¸­åŠ å…¥PyWebIOç›¸å…³çš„è·¯ç”±å³å¯::"

#~ msgid "One route need to be added to communicate with the browser through WebSocket::"
#~ msgstr "éœ€è¦æ·»åŠ ä¸€ä¸ªPyWebIOç›¸å…³çš„è·¯ç”±ï¼Œç”¨æ¥å’Œæµè§ˆå™¨è¿›è¡ŒWebSocketé€šè®¯::"

#~ msgid ""
#~ "See also: `FastAPI doc <https://www.starlette.io/routing/#submounting-routes>`_ , `Starlette doc <https://fastapi.tiangolo.com/advanced/sub-"
#~ "applications/>`_"
#~ msgstr ""
#~ "å‚è§: `FastAPI doc <https://www.starlette.io/routing/#submounting-routes>`_ , `Starlette doc <https://fastapi.tiangolo.com/advanced/sub-"
#~ "applications/>`_"

#~ msgid ""
#~ "`style() <pywebio.output.style>` also accepts a list of output calls, `style() <pywebio.output.style>` will set the CSS style for each item of "
#~ "the list:"
#~ msgstr "``style()`` ä¹Ÿæ¥å—åˆ—è¡¨ä½œä¸ºè¾“å…¥ï¼Œ``style()`` ä¼šä¸ºåˆ—è¡¨çš„æ¯ä¸€é¡¹éƒ½è®¾ç½®CSSæ ·å¼ï¼Œè¿”å›å€¼å¯ä»¥ç›´æ¥è¾“å‡ºï¼Œå¯ç”¨äºä»»ä½•æ¥å— ``put_xxx()`` åˆ—è¡¨çš„åœ°æ–¹:"

#~ msgid "Use `pywebio.platform.tornado.webio_handler()` to get the ``RequestHandler`` class for running PyWebIO applications in Tornado::"
#~ msgstr "ä½¿ç”¨ `pywebio.platform.tornado.webio_handler()` æ¥è·å¾—åœ¨Tornadoä¸­è¿è¡ŒPyWebIOåº”ç”¨çš„ ``RequestHandler`` ç±»::"

#~ msgid ""
#~ "In above code, we use `webio_handler(task_func) <pywebio.platform.tornado.webio_handler>` to get the Tornado `WebSocketHandler <https://www."
#~ "tornadoweb.org/en/stable/websocket.html#tornado.websocket.WebSocketHandler>`_  that communicates with the browser, and bind it to the ``/tool`` "
#~ "path. After starting the Tornado server, you can visit ``http://localhost/tool`` to open the PyWebIO application."
#~ msgstr ""
#~ "ä»¥ä¸Šä»£ç è°ƒç”¨ `webio_handler(task_func) <pywebio.platform.tornado.webio_handler>` æ¥è·å¾—PyWebIOå’Œæµè§ˆå™¨è¿›è¡Œé€šè®¯çš„Tornado `WebSocketHandler "
#~ "<https://www.tornadoweb.org/en/stable/websocket.html#tornado.websocket.WebSocketHandler>`_ ï¼Œå¹¶å°†å…¶ç»‘å®šåœ¨ ``/tool`` è·¯ç”±ä¸‹ã€‚å¯åŠ¨TornadoæœåŠ¡å™¨åï¼Œ"
#~ "è®¿é—® ``http://localhost/tool`` å³å¯æ‰“å¼€PyWebIOåº”ç”¨ã€‚"

#~ msgid ""
#~ "In above code, we use `webio_view(task_func) <pywebio.platform.flask.webio_view>` to get the Flask view of the PyWebIO application, and bind it "
#~ "to ``/tool`` path. After starting the Flask application, visit ``http://localhost/tool`` to open the PyWebIO application."
#~ msgstr ""
#~ "ä»¥ä¸Šä»£ç ä½¿ç”¨ `webio_view(task_func) <pywebio.platform.flask.webio_view>` æ¥è·å¾—è¿è¡ŒPyWebIOåº”ç”¨çš„Flaskè§†å›¾ ï¼Œå¹¶è°ƒç”¨ `Flask.add_url_rule <https://"
#~ "flask.palletsprojects.com/en/1.1.x/api/#flask.Flask.add_url_rule>`_ å°†å…¶ç»‘å®šåœ¨ ``/tool`` è·¯å¾„ä¸‹ã€‚å¯åŠ¨Flaskåº”ç”¨åï¼Œè®¿é—® ``http://localhost/tool`` "
#~ "å³å¯æ‰“å¼€PyWebIOåº”ç”¨ã€‚"

#~ msgid ""
#~ "The `start_server() <pywebio.platform.tornado.start_server>` provide a remote access support, when enabled (by passing `remote_access=True` to "
#~ "`start_server()`), you can get a temporary public network access address for the current application, others can access your application via "
#~ "this address. Using remote access makes it easy to temporarily share the application with others. This service is powered by `localhost.run "
#~ "<https://localhost.run>`_."
#~ msgstr ""
#~ "`start_server() <pywebio.platform.tornado.start_server>` æä¾›äº†è¿œç¨‹è®¿é—®çš„æ”¯æŒï¼Œå½“å¼€å¯è¿œç¨‹è®¿é—®åï¼ˆé€šè¿‡åœ¨ `start_server()` ä¸­ä¼ å…¥ "
#~ "`remote_access=True` å¼€å¯ ï¼‰ï¼Œä½ å°†ä¼šå¾—åˆ°ä¸€ä¸ªç”¨äºè®¿é—®å½“å‰åº”ç”¨çš„ä¸´æ—¶çš„å…¬ç½‘è®¿é—®åœ°å€ï¼Œå…¶ä»–äººä»»ä½•éƒ½å¯ä»¥ä½¿ç”¨æ­¤åœ°å€è®¿é—®ä½ çš„åº”ç”¨ã€‚è¿œç¨‹æ¥å…¥å¯ä»¥å¾ˆæ–¹ä¾¿åœ°å°†"
#~ "åº”ç”¨ä¸´æ—¶åˆ†äº«ç»™å…¶ä»–äººã€‚å½“å‰è¿œç¨‹æ¥å…¥åŠŸèƒ½ç”± `localhost.run <https://localhost.run>`_ æä¾›ã€‚"

#~ msgid ""
#~ "After the PyWebIO session (see :ref:`Server and script mode <server_and_script_mode>` for more information about session) closed, the event "
#~ "callback will not work. You can call the :func:`pywebio.session.hold()` function at the end of the task function to hold the session, so that "
#~ "the event callback will always be available before the browser page is closed by user."
#~ msgstr ""
#~ "åœ¨PyWebIOä¼šè¯(å…³äºä¼šè¯çš„æ¦‚å¿µè§ä¸‹æ–‡ :ref:`Serverä¸scriptæ¨¡å¼ <server_and_script_mode>` )ç»“æŸåï¼Œäº‹ä»¶å›è°ƒä¹Ÿå°†ä¸èµ·ä½œç”¨ï¼Œä½ å¯ä»¥åœ¨ä»»åŠ¡å‡½æ•°æœ«å°¾å¤„ä½¿ç”¨ :"
#~ "func:`pywebio.session.hold()` å‡½æ•°æ¥å°†ä¼šè¯ä¿æŒï¼Œè¿™æ ·åœ¨ç”¨æˆ·å…³é—­æµè§ˆå™¨é¡µé¢å‰ï¼Œäº‹ä»¶å›è°ƒå°†ä¸€ç›´å¯ç”¨ã€‚"

#~ msgid ""
#~ "PyWebIO uses the scope model to give more control to the location of content output. The output area of PyWebIO can be divided into different "
#~ "output domains. The output domain is called Scope in PyWebIO."
#~ msgstr "PyWebIOä½¿ç”¨Scopeæ¨¡å‹æ¥å¯¹å†…å®¹è¾“å‡ºçš„ä½ç½®è¿›è¡Œçµæ´»åœ°æ§åˆ¶ï¼ŒPyWebIOçš„å†…å®¹è¾“å‡ºåŒºå¯ä»¥åˆ’åˆ†å‡ºä¸åŒçš„è¾“å‡ºåŸŸï¼ŒPyWebIOå°†è¾“å‡ºåŸŸç§°ä½œ `Scope` ã€‚"

#~ msgid ""
#~ "The output domain is a container of output content, and each output domain is arranged vertically, and the output domains can also be nested."
#~ msgstr "è¾“å‡ºåŸŸä¸ºè¾“å‡ºå†…å®¹çš„å®¹å™¨ï¼Œå„ä¸ªè¾“å‡ºåŸŸä¹‹é—´ä¸Šä¸‹æ’åˆ—ï¼Œè¾“å‡ºåŸŸä¹Ÿå¯ä»¥è¿›è¡ŒåµŒå¥—ã€‚"

#~ msgid "**Scope related parameters of output function**"
#~ msgstr "**è¾“å‡ºå‡½æ•°çš„scopeç›¸å…³å‚æ•°**"

#~ msgid ""
#~ "The output function (function name like ``put_xxx()``) will output the content to the \"current scope\" by default, and the \"current scope\" of "
#~ "the runtime context can be set by ``use_scope()``."
#~ msgstr "è¾“å‡ºå‡½æ•°ï¼ˆå‡½æ•°åå½¢å¦‚ ``put_xxx()`` ï¼‰åœ¨é»˜è®¤æƒ…å†µä¸‹ï¼Œä¼šå°†å†…å®¹è¾“å‡ºåˆ°\"å½“å‰Scope\"ï¼Œå¯ä»¥é€šè¿‡ ``use_scope()`` è®¾ç½®è¿è¡Œæ—¶ä¸Šä¸‹æ–‡çš„\"å½“å‰Scope\"ã€‚"

#~ msgid "In addition, you can use the ``scope`` parameter of the output function to specify the destination scope to output:"
#~ msgstr "æ­¤å¤–ï¼Œä¹Ÿå¯ä»¥é€šè¿‡è¾“å‡ºå‡½æ•°çš„ ``scope`` å‚æ•°æŒ‡å®šè¾“å‡ºçš„ç›®çš„Scope:"

#~ msgid ""
#~ "In addition to directly specifying the target scope name, the ``scope`` parameter can also accept an integer to determine the scope by indexing "
#~ "the scope stack: 0 means the top level scope(the ROOT Scope), -1 means the current scope, -2 means the scope used before entering the current "
#~ "scope, ..."
#~ msgstr ""
#~ "``scope`` å‚æ•°é™¤äº†ç›´æ¥æŒ‡å®šç›®æ ‡Scopeåï¼Œè¿˜å¯ä»¥ä½¿ç”¨ä¸€ä¸ªæ•´å½¢é€šè¿‡ç´¢å¼•Scopeæ ˆæ¥ç¡®å®šScopeï¼š0è¡¨ç¤ºæœ€é¡¶å±‚ä¹Ÿå°±æ˜¯ROOT Scopeï¼Œ-1è¡¨ç¤ºå½“å‰Scopeï¼Œ-2è¡¨ç¤ºè¿›å…¥å½“å‰"
#~ "Scopeå‰æ‰€ä½¿ç”¨çš„Scopeï¼Œâ€¦â€¦"

#~ msgid ""
#~ "By default, the content output to the same scope will be arranged from top to bottom according to the calling order of the output function. The "
#~ "output content can be inserted into other positions of the target scope by using the ``position`` parameter of the output function."
#~ msgstr ""
#~ "é»˜è®¤æ¡ä»¶ä¸‹ï¼Œåœ¨åŒä¸€Scopeä¸­çš„è¾“å‡ºå†…å®¹ï¼Œä¼šæ ¹æ®è¾“å‡ºå‡½æ•°çš„è°ƒç”¨é¡ºåºä»ä¸Šå¾€ä¸‹æ’åˆ—ï¼Œæœ€åè°ƒç”¨çš„è¾“å‡ºå‡½æ•°ä¼šè¾“å‡ºå†…å®¹åˆ°ç›®æ ‡Scopeçš„åº•éƒ¨ã€‚é€šè¿‡è¾“å‡ºå‡½æ•°çš„ "
#~ "``position`` å‚æ•°å¯ä»¥å°†è¾“å‡ºå†…å®¹æ’å…¥åˆ°ç›®æ ‡Scopeçš„å…¶ä»–ä½ç½®ã€‚"

#~ msgid ""
#~ "Each output item in a scope has an index, the first item's index is 0, and the next item's index is incremented by one. You can also use a "
#~ "negative number to index the items in the scope, -1 means the last item, -2 means the item before the last..."
#~ msgstr ""
#~ "ä¸€ä¸ªScopeä¸­å„æ¬¡è¾“å‡ºçš„å…ƒç´ å…·æœ‰åƒæ•°ç»„ä¸€æ ·çš„ç´¢å¼•ï¼Œæœ€å‰é¢çš„ç¼–å·ä¸º0ï¼Œä»¥æ­¤å¾€åé€’å¢åŠ ä¸€ï¼›åŒæ ·å¯ä»¥ä½¿ç”¨è´Ÿæ•°å¯¹Scopeä¸­çš„å…ƒç´ è¿›è¡Œç´¢å¼•ï¼Œ-1è¡¨ç¤ºæœ€åé¢çš„å…ƒç´ ï¼Œ-2"
#~ "è¡¨ç¤ºæ¬¡åé¢çš„å…ƒç´ â€¦â€¦"

#~ msgid ""
#~ "The ``position`` parameter of output functions accepts an integer. When ``position>=0``, it means to insert content before the item whose index "
#~ "equal ``position``; when ``position<0``, it means to insert content after the item whose index equal ``position``:"
#~ msgstr ""
#~ "``position`` å‚æ•°ç±»å‹ä¸ºæ•´å½¢ï¼Œ ``position>=0`` æ—¶è¡¨ç¤ºè¾“å‡ºå†…å®¹åˆ°ç›®æ ‡Scopeçš„ç¬¬positionå·å…ƒç´ çš„å‰é¢ï¼› ``position<0`` æ—¶è¡¨ç¤ºè¾“å‡ºå†…å®¹åˆ°ç›®æ ‡Scopeç¬¬"
#~ "positionå·å…ƒç´ ä¹‹å:"

#~ msgid "Page environment settings"
#~ msgstr "é¡µé¢ç¯å¢ƒè®¾ç½®"

#~ msgid "**Page Title**"
#~ msgstr "**é¡µé¢æ ‡é¢˜**"

#~ msgid "You can call `set_env(title=...) <pywebio.session.set_env>` to set the page titleã€‚"
#~ msgstr "è°ƒç”¨ `set_env(title=â€¦) <pywebio.session.set_env>` å¯ä»¥è®¾ç½®é¡µé¢æ ‡é¢˜ã€‚"

#~ msgid "**Auto Scroll**"
#~ msgstr "**è‡ªåŠ¨æ»šåŠ¨**"

#~ msgid ""
#~ "When performing some continuous output (such as log output), you may want to scroll the page to the bottom automatically when there is new "
#~ "output. You can call `set_env(auto_scroll_bottom=True) <pywebio.session.set_env>` to enable automatic scrolling. Note that when enabled, only "
#~ "outputting to ROOT scope can trigger automatic scrolling."
#~ msgstr ""
#~ "åœ¨è¿›è¡Œä¸€äº›æŒç»­æ€§çš„è¾“å‡ºæ—¶(æ¯”å¦‚æ—¥å¿—è¾“å‡º)ï¼Œæœ‰æ—¶å¸Œæœ›åœ¨æœ‰æ–°è¾“å‡ºåè‡ªåŠ¨å°†é¡µé¢æ»šåŠ¨åˆ°æœ€ä¸‹æ–¹ï¼Œè¿™æ—¶å¯ä»¥è°ƒç”¨ `set_env(auto_scroll_bottom=True) <pywebio."
#~ "session.set_env>` æ¥å¼€å¯è‡ªåŠ¨æ»šåŠ¨ã€‚\n"
#~ "æ³¨æ„ï¼Œå¼€å¯åï¼Œåªæœ‰è¾“å‡ºåˆ°ROOT Scopeæ‰å¯ä»¥è§¦å‘è‡ªåŠ¨æ»šåŠ¨ã€‚"

#~ msgid "**Output Animation**"
#~ msgstr "**è¾“å‡ºåŠ¨ç”»**"

#~ msgid ""
#~ "By default, PyWebIO will use the fade-in animation effect to display the content. You can use `set_env(output_animation=False) <pywebio.session."
#~ "set_env>` to turn off the animation."
#~ msgstr "PyWebIOåœ¨è¾“å‡ºå†…å®¹æ—¶é»˜è®¤ä¼šä½¿ç”¨æ·¡å…¥çš„åŠ¨ç”»æ•ˆæœæ¥æ˜¾ç¤ºå†…å®¹ï¼Œå¯ä½¿ç”¨ `set_env(output_animation=False) <pywebio.session.set_env>` æ¥å…³é—­åŠ¨ç”»ã€‚"

#~ msgid "To view the effects of environment settings, please visit :demo_host:`set_env Demo </set_env_demo>`"
#~ msgstr "æœ‰å…³ä¸åŒç¯å¢ƒé…ç½®çš„æ•ˆæœå¯æŸ¥çœ‹ :demo_host:`set_env Demo </set_env_demo>`"

#~ msgid "Server mode and Script mode"
#~ msgstr "Serveræ¨¡å¼ä¸Scriptæ¨¡å¼"

#~ msgid ""
#~ "Use `start_server() <pywebio.platform.tornado.start_server>` to start a web server and serve given PyWebIO applications on it. `start_server() "
#~ "<pywebio.platform.tornado.start_server>` accepts a function as PyWebIO application. In addition, `start_server() <pywebio.platform.tornado."
#~ "start_server>` also accepts a list of task function or a dictionary of it, so  one PyWebIO Server can have multiple services with different "
#~ "functions. You can use `go_app() <pywebio.session.go_app>` or `put_link() <pywebio.output.put_link>` to jump between services::"
#~ msgstr ""
#~ "ä½¿ç”¨ `start_server() <pywebio.platform.tornado.start_server>` å¯åŠ¨ä¸€ä¸ªWeb Serveræ¥å°†PyWebIOåº”ç”¨ä½œä¸ºWebæœåŠ¡è¿è¡Œï¼Œ `start_server() <pywebio."
#~ "platform.tornado.start_server>` å¯ä»¥æ¥æ”¶ä¸€ä¸ªå‡½æ•°ä½œä¸ºPyWebIOåº”ç”¨ï¼›\n"
#~ "ä¹Ÿæ”¯æŒä½¿ç”¨å‡½æ•°åˆ—è¡¨æˆ–å­—å…¸ï¼Œä»è€Œä½¿ä¸€ä¸ªPyWebIO Serverä¸‹å¯ä»¥æœ‰å¤šä¸ªä¸åŒåŠŸèƒ½çš„æœåŠ¡ï¼ŒæœåŠ¡ä¹‹é—´å¯ä»¥é€šè¿‡ `go_app() <pywebio.session.go_app>` æˆ– "
#~ "`put_link() <pywebio.output.put_link>` è¿›è¡Œè·³è½¬::"

#~ msgid ""
#~ "def task_1():\n"
#~ "    put_text('task_1')\n"
#~ "    put_buttons(['Go task 2'], [lambda: go_app('task_2')])\n"
#~ "    hold()\n"
#~ "\n"
#~ "def task_2():\n"
#~ "    put_text('task_2')\n"
#~ "    put_buttons(['Go task 1'], [lambda: go_app('task_1')])\n"
#~ "    hold()\n"
#~ "\n"
#~ "def index():\n"
#~ "    put_link('Go task 1', app='task_1')  # Use `app` parameter to specify the task name\n"
#~ "    put_link('Go task 2', app='task_2')\n"
#~ "\n"
#~ "# equal to `start_server({'index': index, 'task_1': task_1, 'task_2': task_2})`\n"
#~ "start_server([index, task_1, task_2])"
#~ msgstr ""
#~ "def task_1():\n"
#~ "    put_text('task_1')\n"
#~ "    put_buttons(['Go task 2'], [lambda: go_app('task_2')])\n"
#~ "    hold()\n"
#~ "\n"
#~ "def task_2():\n"
#~ "    put_text('task_2')\n"
#~ "    put_buttons(['Go task 1'], [lambda: go_app('task_1')])\n"
#~ "    hold()\n"
#~ "\n"
#~ "def index():\n"
#~ "    put_link('Go task 1', app='task_1')  #  ä½¿ç”¨appå‚æ•°æŒ‡å®šä»»åŠ¡å\n"
#~ "    put_link('Go task 2', app='task_2')\n"
#~ "\n"
#~ "# ç­‰ä»·äº start_server({'index': index, 'task_1': task_1, 'task_2': task_2})\n"
#~ "start_server([index, task_1, task_2])"

#~ msgid ""
#~ "Use `path_deploy() <pywebio.platform.path_deploy>` to deploy the PyWebIO applications from a directory. The python file under this directory "
#~ "need contain the ``main`` function to be seen as the PyWebIO application. You can access the application by using the file path as the URL."
#~ msgstr ""
#~ "ä½¿ç”¨ `path_deploy() <pywebio.platform.path_deploy>` å¯ä»¥ä»ä¸€ä¸ªè·¯å¾„ä¸­éƒ¨ç½²PyWebIOåº”ç”¨ã€‚ä½äºè¯¥è·¯å¾„ä¸‹çš„pythonæ–‡ä»¶éœ€è¦åŒ…å«åå­—ä¸º ``main`` çš„PyWebIOä»»"
#~ "åŠ¡å‡½æ•°æ‰èƒ½è¢«è§†ä¸ºPyWebIOåº”ç”¨ç¨‹åºã€‚æœåŠ¡ç«¯ä¼šæ ¹æ®ç”¨æˆ·è®¿é—®çš„URLæ¥ç¡®å®šéœ€è¦åŠ è½½çš„æ–‡ä»¶å¹¶ä»ä¸­è¯»å–PyWebIOåº”ç”¨æ¥è¿è¡Œã€‚"

#~ msgid "For example, given the following folder structure::"
#~ msgstr "ä¾‹å¦‚ï¼Œç»™å®šå¦‚ä¸‹æ–‡ä»¶ç»“æ„::"

#~ msgid ""
#~ "If you use this directory in `path_deploy() <pywebio.platform.path_deploy>`, you can access the PyWebIO application in ``b.py`` by using URL "
#~ "``http://<host>:<port>/A/b``. And if the files have been modified after run `path_deploy() <pywebio.platform.path_deploy>`, you can use "
#~ "``reload`` URL parameter to reload application in the file: ``http://<host>:<port>/A/b?reload``"
#~ msgstr ""
#~ "å¦‚æœä½¿ç”¨ä»¥ä¸Šè·¯å¾„è°ƒç”¨ `path_deploy() <pywebio.platform.path_deploy>` ï¼Œä½ å¯ä»¥é€šè¿‡ URL ``http://<host>:<port>/A/b`` æ¥è®¿é—® ``b.py`` æ–‡ä»¶ä¸­çš„PyWebIO"
#~ "åº”ç”¨ã€‚å½“æ–‡ä»¶åœ¨è¿è¡Œ `path_deploy() <pywebio.platform.path_deploy>` ä¹‹åè¢«ä¿®æ”¹ï¼Œå¯ä»¥ä½¿ç”¨ ``reload`` URLå‚æ•°æ¥é‡è½½æ–‡ä»¶: ``http://<host>:<port>/A/b?"
#~ "reload``"

#~ msgid ""
#~ "You can also use the command ``pywebio-path-deploy`` to start a server just like using `path_deploy() <pywebio.platform.path_deploy>`. For more "
#~ "information, refer ``pywebio-path-deploy --help``"
#~ msgstr ""
#~ "ä½ è¿˜å¯ä»¥ä½¿ç”¨ ``pywebio-path-deploy`` å‘½ä»¤æ¥å¯åŠ¨ä¸€ä¸ªå’Œ `path_deploy() <pywebio.platform.path_deploy>` æ•ˆæœä¸€æ ·çš„serverã€‚å…³äºå‘½ä»¤çš„æ›´å¤šä¿¡æ¯è¯·æŸ¥é˜…å‘½"
#~ "ä»¤å¸®åŠ©ï¼š ``pywebio-path-deploy --help``"

#~ msgid ""
#~ "In Server mode, you can use `pywebio.platform.seo()` to set the `SEO <https://en.wikipedia.org/wiki/Search_engine_optimization>`_ information. "
#~ "If ``seo()`` is not used, the `docstring <https://www.python.org/dev/peps/pep-0257/>`_ of the task function will be regarded as SEO information "
#~ "by default."
#~ msgstr ""
#~ "åœ¨Serveræ¨¡å¼ä¸‹ï¼Œå¯ä»¥ä½¿ç”¨ `pywebio.platform.seo()` å‡½æ•°æ¥è®¾ç½®ä»»åŠ¡å‡½æ•°SEOä¿¡æ¯ï¼ˆåœ¨è¢«æœç´¢å¼•æ“ç´¢å¼•æ—¶æä¾›çš„ç½‘é¡µä¿¡æ¯ï¼ŒåŒ…å«åº”ç”¨æ ‡é¢˜å’Œåº”ç”¨ç®€ä»‹ï¼‰ï¼Œå¦‚æœä¸ä½¿"
#~ "ç”¨ ``seo()`` å‡½æ•°ï¼Œé»˜è®¤æ¡ä»¶ä¸‹ï¼ŒPyWebIOä¼šå°†ä»»åŠ¡å‡½æ•°çš„å‡½æ•°æ³¨é‡Šä½œä¸ºSEOä¿¡æ¯ï¼ˆåº”ç”¨æ ‡é¢˜å’Œç®€ä»‹ä¹‹é—´ä½¿ç”¨ä¸€ä¸ªç©ºè¡Œåˆ†éš”ï¼‰ã€‚ "

#~ msgid "In Script mode, PyWebIO input and output functions can be called anywhere."
#~ msgstr "Scriptæ¨¡å¼ä¸‹ï¼Œåœ¨ä»»ä½•ä½ç½®éƒ½å¯ä»¥è°ƒç”¨PyWebIOçš„äº¤äº’å‡½æ•°ã€‚"

#~ msgid ""
#~ "The close of session may also be caused by the user closing the browser page. After the browser page is closed, PyWebIO input function calls "
#~ "that have not yet returned in the current session will cause `SessionClosedException <pywebio.exceptions.SessionClosedException>`, and "
#~ "subsequent calls to PyWebIO interactive functions will cause `SessionNotFoundException <pywebio.exceptions.SessionNotFoundException>` or "
#~ "`SessionClosedException <pywebio.exceptions.SessionClosedException>`."
#~ msgstr ""
#~ "ä¼šè¯è¿˜ä¼šå› ä¸ºç”¨æˆ·çš„å…³é—­æµè§ˆå™¨è€Œç»“æŸï¼Œè¿™æ—¶å½“å‰ä¼šè¯å†…è¿˜æœªè¿”å›çš„PyWebIOè¾“å…¥å‡½æ•°è°ƒç”¨å°†æŠ›å‡º `SessionClosedException <pywebio.exceptions."
#~ "SessionClosedException>` å¼‚å¸¸ï¼Œä¹‹åå¯¹äºPyWebIOäº¤äº’å‡½æ•°çš„è°ƒç”¨å°†ä¼šäº§ç”Ÿ `SessionNotFoundException <pywebio.exceptions.SessionNotFoundException>` æˆ– "
#~ "`SessionClosedException <pywebio.exceptions.SessionClosedException>` å¼‚å¸¸ã€‚"

#~ msgid ""
#~ "You can use `defer_call(func) <pywebio.session.defer_call>` to set the function to be called when the session closes. Whether it is because the "
#~ "user closes the page or the task finishes to cause session closed, the function set by `defer_call(func) <pywebio.session.defer_call>` will be "
#~ "executed. `defer_call(func) <pywebio.session.defer_call>` can be used for resource cleaning. You can call `defer_call(func) <pywebio.session."
#~ "defer_call>` multiple times in the session, and the set functions will be executed sequentially after the session closes."
#~ msgstr ""
#~ "å¯ä»¥ä½¿ç”¨ `defer_call(func) <pywebio.session.defer_call>` æ¥è®¾ç½®ä¼šè¯ç»“æŸæ—¶éœ€è¦è°ƒç”¨çš„å‡½æ•°ã€‚æ— è®ºæ˜¯å› ä¸ºç”¨æˆ·ä¸»åŠ¨å…³é—­é¡µé¢è¿˜æ˜¯ä»»åŠ¡ç»“æŸä½¿å¾—ä¼šè¯å…³é—­ï¼Œè®¾ç½®"
#~ "çš„å‡½æ•°éƒ½ä¼šè¢«æ‰§è¡Œã€‚\n"
#~ "`defer_call(func) <pywebio.session.defer_call>` å¯ä»¥ç”¨äºèµ„æºæ¸…ç†ç­‰å·¥ä½œã€‚åœ¨ä¼šè¯ä¸­å¯ä»¥å¤šæ¬¡è°ƒç”¨ `defer_call() <pywebio.session.defer_call>` ,ä¼šè¯ç»“"
#~ "æŸåå°†ä¼šé¡ºåºæ‰§è¡Œè®¾ç½®çš„å‡½æ•°ã€‚"

#~ msgid "Integration with web framework"
#~ msgstr "ä¸Webæ¡†æ¶é›†æˆ"

#~ msgid ""
#~ "The PyWebIO application can be integrated into an existing Python Web project, the PyWebIO application and the Web project share a web "
#~ "framework. PyWebIO currently supports integration with Flask, Tornado, Django, aiohttp and FastAPI(Starlette) web frameworks."
#~ msgstr ""
#~ "å¯ä»¥å°†PyWebIOåº”ç”¨é›†æˆåˆ°ç°æœ‰çš„Python Webé¡¹ç›®ä¸­ï¼ŒPyWebIOåº”ç”¨ä¸Webé¡¹ç›®å…±ç”¨ä¸€ä¸ªWebæ¡†æ¶ã€‚ç›®å‰æ”¯æŒä¸Flaskã€Tornadoã€Djangoã€aiohttpå’Œ"
#~ "FastAPI(Starlette) Webæ¡†æ¶çš„é›†æˆã€‚"

#~ msgid "The integration methods of those web frameworks are as follows:"
#~ msgstr "ä¸åŒWebæ¡†æ¶çš„é›†æˆæ–¹æ³•å¦‚ä¸‹ï¼š "

#~ msgid ""
#~ "Use `pywebio.platform.tornado.webio_handler()` to get the `WebSocketHandler <https://www.tornadoweb.org/en/stable/websocket.html#tornado."
#~ "websocket.WebSocketHandler>`_ class for running PyWebIO applications in Tornado::"
#~ msgstr ""
#~ "ä½¿ç”¨ `pywebio.platform.tornado.webio_handler()` æ¥è·å–åœ¨Tornadoä¸­è¿è¡ŒPyWebIOåº”ç”¨çš„ `WebSocketHandler <https://www.tornadoweb.org/en/stable/"
#~ "websocket.html#tornado.websocket.WebSocketHandler>`_ ç±»::"

#~ msgid ""
#~ "In above code, we add a routing rule to bind the ``WebSocketHandler`` of the PyWebIO application to the ``/tool`` path. After starting the "
#~ "Tornado server, you can visit ``http://localhost/tool`` to open the PyWebIO application."
#~ msgstr ""
#~ "ä»¥ä¸Šä»£ç å°† PyWebIO åº”ç”¨çš„ ``WebSocketHandler`` ç»‘å®šåˆ°äº† ``/tool`` è·¯å¾„ä¸‹ã€‚ å¯åŠ¨Tornadoåï¼Œè®¿é—® ``http://localhost/tool``å³å¯æ‰“å¼€PyWebIOåº”ç”¨ã€‚"

#~ msgid ""
#~ "PyWebIO uses the WebSocket protocol to communicate with the browser in Tornado. If your Tornado application is behind a reverse proxy (such as "
#~ "Nginx), you may need to configure the reverse proxy to support the WebSocket protocol. :ref:`Here <nginx_ws_config>` is an example of Nginx "
#~ "WebSocket configuration."
#~ msgstr ""
#~ "å½“ä½¿ç”¨Tornadoåç«¯æ—¶ï¼ŒPyWebIOä½¿ç”¨WebSocketåè®®å’Œæµè§ˆå™¨è¿›è¡Œé€šè®¯ï¼Œå¦‚æœä½ çš„Tornadoåº”ç”¨å¤„åœ¨åå‘ä»£ç†(æ¯”å¦‚Nginx)ä¹‹åï¼Œå¯èƒ½éœ€è¦ç‰¹åˆ«é…ç½®åå‘ä»£ç†æ¥æ”¯æŒ"
#~ "WebSocketåè®®ï¼Œ:ref:`è¿™é‡Œ <nginx_ws_config>` æœ‰ä¸€ä¸ªNginxé…ç½®WebSocketçš„ä¾‹å­ã€‚"

#~ msgid "Use `pywebio.platform.flask.webio_view()` to get the view function for running PyWebIO applications in Flask::"
#~ msgstr "ä½¿ç”¨ `pywebio.platform.flask.webio_view()` æ¥è·å–åœ¨Flaskä¸­è¿è¡ŒPyWebIOåº”ç”¨çš„è§†å›¾å‡½æ•°::"

#~ msgid ""
#~ "In above code, we add a routing rule to bind the view function of the PyWebIO application to the ``/tool`` path. After starting the Flask "
#~ "application, visit ``http://localhost/tool`` to open the PyWebIO application."
#~ msgstr ""
#~ "ä»¥ä¸Šä»£ç ä½¿ç”¨æ·»åŠ äº†ä¸€æ¡è·¯ç”±è§„åˆ™å°†PyWebIOåº”ç”¨çš„è§†å›¾å‡½æ•°ç»‘å®šåˆ° ``/tool`` è·¯å¾„ä¸‹ã€‚\n"
#~ "å¯åŠ¨Flaskåº”ç”¨åï¼Œè®¿é—® ``http://localhost/tool`` å³å¯æ‰“å¼€PyWebIOåº”ç”¨"

#~ msgid "Use `pywebio.platform.django.webio_view()` to get the view function for running PyWebIO applications in Django::"
#~ msgstr "ä½¿ç”¨ `pywebio.platform.django.webio_view()` æ¥è·å–åœ¨Djangoä¸­è¿è¡ŒPyWebIOåº”ç”¨çš„è§†å›¾å‡½æ•°::"

#~ msgid ""
#~ "In above code, we add a routing rule to bind the view function of the PyWebIO application to the ``/tool`` path. After starting the Django "
#~ "server, visit ``http://localhost/tool`` to open the PyWebIO application"
#~ msgstr ""
#~ "ä»¥ä¸Šä»£ç ä½¿ç”¨æ·»åŠ äº†ä¸€æ¡è·¯ç”±è§„åˆ™å°†PyWebIOåº”ç”¨çš„è§†å›¾å‡½æ•°ç»‘å®šåˆ° ``/tool`` è·¯å¾„ä¸‹ã€‚\n"
#~ "å¯åŠ¨Djangoåº”ç”¨åï¼Œè®¿é—® ``http://localhost/tool`` å³å¯æ‰“å¼€PyWebIOåº”ç”¨"

#~ msgid ""
#~ "Use `pywebio.platform.aiohttp.webio_handler()` to get the `Request Handler <https://docs.aiohttp.org/en/stable/web_quickstart.html#aiohttp-web-"
#~ "handler>`_ coroutine for running PyWebIO applications in aiohttp::"
#~ msgstr ""
#~ "ä½¿ç”¨ `pywebio.platform.aiohttp.webio_handler()` æ¥è·å–åœ¨aiohttpä¸­è¿è¡ŒPyWebIOåº”ç”¨çš„ `Request Handler <https://docs.aiohttp.org/en/stable/"
#~ "web_quickstart.html#aiohttp-web-handler>`_ åç¨‹::"

#~ msgid "After starting the aiohttp server, visit ``http://localhost/tool`` to open the PyWebIO application"
#~ msgstr "å¯åŠ¨aiohttpåº”ç”¨åï¼Œè®¿é—® ``http://localhost/tool`` å³å¯æ‰“å¼€PyWebIOåº”ç”¨"

#~ msgid ""
#~ "PyWebIO uses the WebSocket protocol to communicate with the browser in aiohttp. If your aiohttp server is behind a reverse proxy (such as "
#~ "Nginx), you may need to configure the reverse proxy to support the WebSocket protocol. :ref:`Here <nginx_ws_config>` is an example of Nginx "
#~ "WebSocket configuration."
#~ msgstr ""
#~ "å½“ä½¿ç”¨aiohttpåç«¯æ—¶ï¼ŒPyWebIOä½¿ç”¨WebSocketåè®®å’Œæµè§ˆå™¨è¿›è¡Œé€šè®¯ï¼Œå¦‚æœä½ çš„aiohttpåº”ç”¨å¤„åœ¨åå‘ä»£ç†(æ¯”å¦‚Nginx)ä¹‹åï¼Œ\n"
#~ "å¯èƒ½éœ€è¦ç‰¹åˆ«é…ç½®åå‘ä»£ç†æ¥æ”¯æŒWebSocketåè®®ï¼Œ:ref:`è¿™é‡Œ <nginx_ws_config>` æœ‰ä¸€ä¸ªNginxé…ç½®WebSocketçš„ä¾‹å­ã€‚"

#~ msgid ""
#~ "Use `pywebio.platform.fastapi.webio_routes()` to get the FastAPI/Starlette routes for running PyWebIO applications. You can mount the routes to "
#~ "your FastAPI/Starlette app."
#~ msgstr ""
#~ "ä½¿ç”¨ `pywebio.platform.fastapi.webio_routes()` æ¥è·å–åœ¨FastAPI/Starletteä¸­è¿è¡ŒPyWebIOåº”ç”¨çš„è·¯ç”±ç»„ä»¶ï¼Œä½ å¯ä»¥å°†å…¶æŒ‚è½½åœ¨åˆ°FastAPI/Starletteåº”ç”¨ä¸­ã€‚"

#~ msgid "After starting the server by using ``uvicorn <module>:app`` , visit ``http://localhost:8000/tool/`` to open the PyWebIO application"
#~ msgstr "ä½¿ç”¨ ``uvicorn <module>:app` å¯åŠ¨serveråï¼Œè®¿é—® ``http://localhost:8000/tool/`` å³å¯æ‰“å¼€PyWebIOåº”ç”¨"

#~ msgid ""
#~ "PyWebIO uses the WebSocket protocol to communicate with the browser in FastAPI/Starlette. If your server is behind a reverse proxy (such as "
#~ "Nginx), you may need to configure the reverse proxy to support the WebSocket protocol. :ref:`Here <nginx_ws_config>` is an example of Nginx "
#~ "WebSocket configuration."
#~ msgstr ""
#~ "å½“ä½¿ç”¨FastAPIæˆ–Starletteåç«¯æ—¶ï¼ŒPyWebIOä½¿ç”¨WebSocketåè®®å’Œæµè§ˆå™¨è¿›è¡Œé€šè®¯ï¼Œå¦‚æœä½ çš„aiohttpåº”ç”¨å¤„åœ¨åå‘ä»£ç†(æ¯”å¦‚Nginx)ä¹‹åï¼Œ\n"
#~ "å¯èƒ½éœ€è¦ç‰¹åˆ«é…ç½®åå‘ä»£ç†æ¥æ”¯æŒWebSocketåè®®ï¼Œ:ref:`è¿™é‡Œ <nginx_ws_config>` æœ‰ä¸€ä¸ªNginxé…ç½®WebSocketçš„ä¾‹å­ã€‚"

#~ msgid "**Deployment in production**"
#~ msgstr "**ç”Ÿäº§ç¯å¢ƒéƒ¨ç½²**"

#~ msgid ""
#~ "In your production system, you may want to deploy the web applications with some WSGI/ASGI servers such as uWSGI, Gunicorn, and Uvicorn. Since "
#~ "PyWebIO applications store session state in memory of process, when you use HTTP-based sessions (Flask and Django) and spawn multiple workers to "
#~ "handle requests, the request may be dispatched to a process that does not hold the session to which the request belongs. So you can only start "
#~ "one worker to handle requests when using Flask or Django backend."
#~ msgstr ""
#~ "åœ¨ç”Ÿäº§ç¯å¢ƒä¸­ï¼Œä½ å¯èƒ½ä¼šä½¿ç”¨ä¸€äº› WSGI/ASGI æœåŠ¡å™¨ï¼ˆå¦‚ uWSGIã€Gunicornã€Uvicornï¼‰éƒ¨ç½² Web åº”ç”¨ç¨‹åºã€‚ç”±äº PyWebIO åº”ç”¨ç¨‹åºä¼šåœ¨è¿›ç¨‹ä¸­å­˜å‚¨ä¼šè¯çŠ¶æ€ï¼Œå½“"
#~ "ä½¿ç”¨åŸºäº HTTP çš„ä¼šè¯ï¼ˆä½¿ç”¨Flask å’Œ Djangoåç«¯æ—¶ï¼‰å¹¶ç”Ÿæˆå¤šä¸ªè¿›ç¨‹æ¥å¤„ç†è¯·æ±‚æ—¶ï¼Œè¯·æ±‚å¯èƒ½ä¼šè¢«åˆ†å‘åˆ°é”™è¯¯çš„è¿›ç¨‹ä¸­ã€‚å› æ­¤ï¼Œåœ¨ä½¿ç”¨åŸºäº HTTP çš„ä¼šè¯æ—¶ï¼Œåªèƒ½"
#~ "å¯åŠ¨ä¸€ä¸ªè¿›ç¨‹æ¥å¤„ç†è¯·æ±‚ã€‚"

#~ msgid ""
#~ "If you still want to use multiple processes to increase concurrency, one way is to use Uvicorn+FastAPI, or you can also start multiple Tornado/"
#~ "aiohttp processes and add external load balancer (such as HAProxy or nginx) before them. Those backends use the WebSocket protocol to "
#~ "communicate with the browser in PyWebIO, so there is no the issue as described above."
#~ msgstr ""
#~ "å¦‚æœä»ç„¶å¸Œæœ›ä½¿ç”¨å¤šè¿›ç¨‹æ¥æé«˜å¹¶å‘ï¼Œä¸€ç§æ–¹å¼æ˜¯ä½¿ç”¨ Uvicorn+FastAPIï¼Œæˆ–è€…ä½ ä¹Ÿå¯ä»¥å¯åŠ¨å¤šä¸ªTornado/aiohttpè¿›ç¨‹ï¼Œå¹¶åœ¨å®ƒä»¬ä¹‹å‰æ·»åŠ å¤–éƒ¨çš„è´Ÿè½½å‡è¡¡è½¯ä»¶"
#~ "ï¼ˆå¦‚ HAProxy æˆ– nginxï¼‰ã€‚è¿™äº›åç«¯ä½¿ç”¨ WebSocket åè®®ä¸æµè§ˆå™¨è¿›è¡Œé€šä¿¡ï¼Œæ‰€ä»¥ä¸å­˜åœ¨ä¸Šè¿°é—®é¢˜ã€‚"

#~ msgid "**Static resources Hosting**"
#~ msgstr "**PyWebIOé™æ€èµ„æºçš„æ‰˜ç®¡**"

#~ msgid ""
#~ "By default, the front-end of PyWebIO gets required static resources from CDN. If you want to deploy PyWebIO applications in an offline "
#~ "environment, you need to host static files by yourself, and set the ``cdn`` parameter of ``webio_view()`` or ``webio_handler()`` to ``False``."
#~ msgstr ""
#~ "PyWebIOé»˜è®¤ä½¿ç”¨CDNæ¥è·å–å‰ç«¯çš„é™æ€èµ„æºï¼Œå¦‚æœè¦å°†PyWebIOåº”ç”¨éƒ¨ç½²åˆ°ç¦»çº¿ç¯å¢ƒä¸­ï¼Œéœ€è¦è‡ªè¡Œæ‰˜ç®¡é™æ€æ–‡ä»¶ï¼Œ\n"
#~ "å¹¶å°† ``webio_view()`` æˆ– ``webio_handler()`` çš„ ``cdn`` å‚æ•°è®¾ç½®ä¸º ``False`` ã€‚"

#~ msgid ""
#~ "When setting ``cdn=False`` , you need to host the static resources in the same directory as the PyWebIO application. In addition, you can also "
#~ "pass a string to ``cdn`` parameter to directly set the URL of PyWebIO static resources directory."
#~ msgstr ""
#~ "``cdn=False``  æ—¶éœ€è¦å°†é™æ€èµ„æºæ‰˜ç®¡åœ¨å’ŒPyWebIOåº”ç”¨åŒçº§çš„ç›®å½•ä¸‹ã€‚\n"
#~ "åŒæ—¶ï¼Œä¹Ÿå¯ä»¥é€šè¿‡ ``cdn`` å‚æ•°ç›´æ¥è®¾ç½®PyWebIOé™æ€èµ„æºçš„URLç›®å½•ã€‚"

#~ msgid ""
#~ "The path of the static file of PyWebIO is stored in ``pywebio.STATIC_PATH``, you can use the command ``python3 -c \"import pywebio; "
#~ "print(pywebio.STATIC_PATH)\"`` to print it out."
#~ msgstr ""
#~ "PyWebIOçš„é™æ€æ–‡ä»¶çš„è·¯å¾„ä¿å­˜åœ¨ ``pywebio.STATIC_PATH`` ä¸­ï¼Œå¯ä½¿ç”¨å‘½ä»¤ ``python3 -c \"import pywebio; print(pywebio.STATIC_PATH)\"`` å°†å…¶æ‰“å°å‡ºæ¥ã€‚"

#~ msgid ""
#~ "``start_server()`` and ``path_deploy()`` also support ``cdn`` parameter, if it is set to ``False``, the static resource will be hosted in local "
#~ "server automatically, without manual hosting."
#~ msgstr "ä½¿ç”¨ ``start_server()`` å¯åŠ¨çš„åº”ç”¨ï¼Œå¦‚æœå°† ``cdn`` å‚æ•°è®¾ç½®ä¸º ``False`` ï¼Œä¼šè‡ªåŠ¨å¯åŠ¨ä¸€ä¸ªæœ¬åœ°çš„é™æ€èµ„æºæ‰˜ç®¡æœåŠ¡ï¼Œæ— éœ€æ‰‹åŠ¨æ‰˜ç®¡ã€‚"

#~ msgid "Coroutine-based session"
#~ msgstr "åŸºäºåç¨‹çš„ä¼šè¯"

#~ msgid ""
#~ "This section will introduce the advanced features of PyWebIO --- coroutine-based session. In most cases, you donâ€™t need it. All functions or "
#~ "methods in PyWebIO that are only used for coroutine sessions are specifically noted in the document."
#~ msgstr "å…³äºåç¨‹å†…å®¹å±äºé«˜çº§ç‰¹æ€§ï¼Œæ‚¨ä¸å¿…ä½¿ç”¨æ­¤éƒ¨åˆ†ä¹Ÿå¯ä»¥å®ç°PyWebIOæ”¯æŒçš„å…¨éƒ¨åŠŸèƒ½ã€‚PyWebIOä¸­æ‰€æœ‰ä»…ç”¨äºåç¨‹ä¼šè¯çš„å‡½æ•°æˆ–æ–¹æ³•éƒ½åœ¨æ–‡æ¡£ä¸­æœ‰ç‰¹åˆ«è¯´æ˜ã€‚"

#~ msgid ""
#~ "PyWebIO's session is based on thread by default. Each time a user opens a session connection to the server, PyWebIO will start a thread to run "
#~ "the task function. In addition to thread-based sessions, PyWebIO also provides coroutine-based sessions. Coroutine-based sessions accept "
#~ "coroutine functions as task functions."
#~ msgstr ""
#~ "PyWebIOçš„ä¼šè¯å®ç°é»˜è®¤æ˜¯åŸºäºçº¿ç¨‹çš„ï¼Œç”¨æˆ·æ¯æ‰“å¼€ä¸€ä¸ªå’ŒæœåŠ¡ç«¯çš„ä¼šè¯è¿æ¥ï¼ŒPyWebIOä¼šå¯åŠ¨ä¸€ä¸ªçº¿ç¨‹æ¥è¿è¡Œä»»åŠ¡å‡½æ•°ã€‚\n"
#~ "é™¤äº†åŸºäºçº¿ç¨‹çš„ä¼šè¯ï¼ŒPyWebIOè¿˜æä¾›äº†åŸºäºåç¨‹çš„ä¼šè¯ã€‚åŸºäºåç¨‹çš„ä¼šè¯æ¥å—åç¨‹å‡½æ•°ä½œä¸ºä»»åŠ¡å‡½æ•°ã€‚"

#~ msgid ""
#~ "The session based on the coroutine is a single-thread model, which means that all sessions run in a single thread. For IO-bound tasks, "
#~ "coroutines take up fewer resources than threads and have performance comparable to threads. In addition, the context switching of the coroutine "
#~ "is predictable, which can reduce the need for program synchronization and locking, and can effectively avoid most critical section problems."
#~ msgstr ""
#~ "åŸºäºåç¨‹çš„ä¼šè¯ä¸ºå•çº¿ç¨‹æ¨¡å‹ï¼Œæ‰€æœ‰ä¼šè¯éƒ½è¿è¡Œåœ¨ä¸€ä¸ªçº¿ç¨‹å†…ã€‚å¯¹äºIOå¯†é›†å‹çš„ä»»åŠ¡ï¼Œåç¨‹æ¯”çº¿ç¨‹å ç”¨æ›´å°‘çš„èµ„æºåŒæ—¶åˆæ‹¥æœ‰åª²ç¾äºçº¿ç¨‹çš„æ€§èƒ½ã€‚\n"
#~ "å¦å¤–ï¼Œåç¨‹çš„ä¸Šä¸‹æ–‡åˆ‡æ¢å…·æœ‰å¯é¢„æµ‹æ€§ï¼Œèƒ½å¤Ÿå‡å°‘ç¨‹åºåŒæ­¥ä¸åŠ é”çš„éœ€è¦ï¼Œå¯ä»¥æœ‰æ•ˆé¿å…å¤§å¤šæ•°ä¸´ç•ŒåŒºé—®é¢˜ã€‚"

#~ msgid "Using coroutine session"
#~ msgstr "ä½¿ç”¨åç¨‹ä¼šè¯"

#~ msgid ""
#~ "To use coroutine-based session, you need to use the ``async`` keyword to declare the task function as a coroutine function, and use the "
#~ "``await`` syntax to call the PyWebIO input function:"
#~ msgstr "è¦ä½¿ç”¨åŸºäºåç¨‹çš„ä¼šè¯ï¼Œéœ€è¦ä½¿ç”¨ ``async`` å…³é”®å­—å°†ä»»åŠ¡å‡½æ•°å£°æ˜ä¸ºåç¨‹å‡½æ•°ï¼Œå¹¶ä½¿ç”¨ ``await`` è¯­æ³•è°ƒç”¨PyWebIOè¾“å…¥å‡½æ•°:"

#~ msgid ""
#~ "In the coroutine task function, you can also use ``await`` to call other coroutines or ( `awaitable objects <https://docs.python.org/3/library/"
#~ "asyncio-task.html#asyncio-awaitables>`_ ) in the standard library `asyncio <https://docs.python.org/3/library/asyncio.html>`_:"
#~ msgstr ""
#~ "åœ¨åç¨‹ä»»åŠ¡å‡½æ•°ä¸­ï¼Œä¹Ÿå¯ä»¥ä½¿ç”¨ ``await`` è°ƒç”¨å…¶ä»–åç¨‹æˆ–æ ‡å‡†åº“ `asyncio <https://docs.python.org/3/library/asyncio.html>`_ ä¸­çš„å¯ç­‰å¾…å¯¹è±¡"
#~ "( `awaitable objects <https://docs.python.org/3/library/asyncio-task.html#asyncio-awaitables>`_ ):"

#~ msgid ""
#~ "In coroutine-based session, all input functions defined in the :doc:`pywebio.input </input>` module need to use ``await`` syntax to get the "
#~ "return value. Forgetting to use ``await`` will be a common error when using coroutine-based session."
#~ msgstr ""
#~ "åœ¨åŸºäºåç¨‹çš„ä¼šè¯ä¸­ï¼Œ :doc:`pywebio.input </input>` æ¨¡å—ä¸­çš„å®šä¹‰è¾“å…¥å‡½æ•°éƒ½éœ€è¦ä½¿ç”¨ ``await`` è¯­æ³•æ¥è·å–è¿”å›å€¼ï¼Œå¿˜è®°ä½¿ç”¨ ``await`` å°†ä¼šæ˜¯åœ¨ä½¿ç”¨åŸºäº"
#~ "åç¨‹çš„ä¼šè¯æ—¶å¸¸å‡ºç°çš„é”™è¯¯ã€‚"

#~ msgid "Other functions that need to use ``await`` syntax in the coroutine session are:"
#~ msgstr "å…¶ä»–åœ¨åç¨‹ä¼šè¯ä¸­ä¹Ÿéœ€è¦ä½¿ç”¨ ``await`` è¯­æ³•æ¥è¿›è¡Œè°ƒç”¨å‡½æ•°æœ‰:"

#~ msgid ""
#~ "Although the PyWebIO coroutine session is compatible with the ``awaitable objects`` in the standard library ``asyncio``, the ``asyncio`` library "
#~ "is not compatible with the ``awaitable objects`` in the PyWebIO coroutine session."
#~ msgstr ""
#~ "è™½ç„¶PyWebIOçš„åç¨‹ä¼šè¯å…¼å®¹æ ‡å‡†åº“ ``asyncio`` ä¸­çš„ ``awaitable objects`` ï¼Œä½† ``asyncio`` åº“ä¸å…¼å®¹PyWebIOåç¨‹ä¼šè¯ä¸­çš„ ``awaitable objects`` ."

#~ msgid ""
#~ "That is to say, you can't pass PyWebIO ``awaitable objects`` to the ``asyncio`` functions that accept ``awaitable objects``. For example, the "
#~ "following calls are **not supported** ::"
#~ msgstr ""
#~ "ä¹Ÿå°±æ˜¯è¯´ï¼Œæ— æ³•å°†PyWebIOä¸­çš„ ``awaitable objects`` ä¼ å…¥ ``asyncio`` ä¸­çš„æ¥å— ``awaitable objects`` ä½œä¸ºå‚æ•°çš„å‡½æ•°ä¸­ï¼Œæ¯”å¦‚å¦‚ä¸‹è°ƒç”¨æ˜¯ **ä¸è¢«æ”¯æŒçš„"
#~ "** ::"

#~ msgid "Concurrency in coroutine-based sessions"
#~ msgstr "åç¨‹ä¼šè¯çš„å¹¶å‘"

#~ msgid ""
#~ "In coroutine-based session, you can start new thread, but you cannot call PyWebIO interactive functions in it (`register_thread() <pywebio."
#~ "session.register_thread>` is not available in coroutine session). But you can use `run_async(coro) <pywebio.session.run_async>` to execute a "
#~ "coroutine object asynchronously, and PyWebIO interactive functions can be used in the new coroutine:"
#~ msgstr ""
#~ "åœ¨åŸºäºåç¨‹çš„ä¼šè¯ä¸­ï¼Œä½ å¯ä»¥å¯åŠ¨çº¿ç¨‹ï¼Œä½†æ˜¯æ— æ³•åœ¨å…¶ä¸­è°ƒç”¨PyWebIOäº¤äº’å‡½æ•°ï¼ˆ `register_thread() <pywebio.session.register_thread>` åœ¨åç¨‹ä¼šè¯ä¸­ä¸å¯"
#~ "ç”¨ï¼‰ã€‚\n"
#~ "ä½†ä½ å¯ä»¥ä½¿ç”¨ `run_async(coro) <pywebio.session.run_async>` æ¥å¼‚æ­¥æ‰§è¡Œä¸€ä¸ªåç¨‹å¯¹è±¡ï¼Œæ–°åç¨‹å†…å¯ä»¥ä½¿ç”¨PyWebIOäº¤äº’å‡½æ•°:"

#~ msgid ""
#~ "`run_async(coro) <pywebio.session.run_async>` returns a `TaskHandler <pywebio.session.coroutinebased.TaskHandler>`, which can be used to query "
#~ "the running status of the coroutine or close the coroutine."
#~ msgstr ""
#~ "`run_async(coro) <pywebio.session.run_async>` è¿”å›ä¸€ä¸ª `TaskHandler <pywebio.session.coroutinebased.TaskHandler>` ï¼Œé€šè¿‡è¯¥ `TaskHandler <pywebio."
#~ "session.coroutinebased.TaskHandler>` å¯ä»¥æŸ¥è¯¢åç¨‹è¿è¡ŒçŠ¶æ€å’Œå…³é—­åç¨‹ã€‚"

#~ msgid ""
#~ "Similar to thread-based session, in coroutine-based session, when the task function and the coroutine running through `run_async() <pywebio."
#~ "session.run_async>` in the session are all finished, the session is closed."
#~ msgstr ""
#~ "ä¸åŸºäºçº¿ç¨‹çš„ä¼šè¯ç±»ä¼¼ï¼Œåœ¨åŸºäºåç¨‹çš„ä¼šè¯ä¸­ï¼Œå½“ä»»åŠ¡å‡½æ•°å’Œåœ¨ä¼šè¯å†…é€šè¿‡ `run_async() <pywebio.session.run_async>` è¿è¡Œçš„åç¨‹å…¨éƒ¨ç»“æŸåï¼Œä¼šè¯å…³é—­ã€‚"

#~ msgid ""
#~ "If the close of the session is caused by the user closing the browser, the behavior of PyWebIO is the same as :ref:`Thread-based session "
#~ "<session_close>`: After the browser page closed, PyWebIO input function calls that have not yet returned in the current session will cause "
#~ "`SessionClosedException <pywebio.exceptions.SessionClosedException>`, and subsequent calls to PyWebIO interactive functions will cause "
#~ "`SessionNotFoundException <pywebio.exceptions.SessionNotFoundException>` or `SessionClosedException <pywebio.exceptions.SessionClosedException>`."
#~ msgstr ""
#~ "å¯¹äºå› ä¸ºç”¨æˆ·çš„å…³é—­æµè§ˆå™¨è€Œé€ æˆçš„ä¼šè¯ç»“æŸï¼Œå¤„ç†é€»è¾‘å’Œ :ref:`åŸºäºçº¿ç¨‹çš„ä¼šè¯ <session_close>` ä¸€è‡´:\n"
#~ "æ­¤æ—¶å½“å‰ä¼šè¯å†…è¿˜æœªè¿”å›çš„PyWebIOè¾“å…¥å‡½æ•°è°ƒç”¨å°†æŠ›å‡º `SessionClosedException <pywebio.exceptions.SessionClosedException>` å¼‚å¸¸ï¼Œä¹‹åå¯¹äºPyWebIOäº¤äº’"
#~ "å‡½æ•°çš„è°ƒç”¨å°†ä¼šäº§ç”Ÿ `SessionNotFoundException <pywebio.exceptions.SessionNotFoundException>` æˆ– `SessionClosedException <pywebio.exceptions."
#~ "SessionClosedException>` å¼‚å¸¸ã€‚"

#~ msgid "`defer_call(func) <pywebio.session.defer_call>` also available in coroutine session."
#~ msgstr "åç¨‹ä¼šè¯ä¹ŸåŒæ ·æ”¯æŒä½¿ç”¨ `defer_call(func) <pywebio.session.defer_call>` æ¥è®¾ç½®ä¼šè¯ç»“æŸæ—¶éœ€è¦è°ƒç”¨çš„å‡½æ•°ã€‚"

#~ msgid "Integration with Web Framework"
#~ msgstr "åç¨‹ä¼šè¯ä¸Webæ¡†æ¶é›†æˆ"

#~ msgid "The PyWebIO application that using coroutine-based session can also be integrated to the web framework."
#~ msgstr "åŸºäºåç¨‹çš„ä¼šè¯åŒæ ·å¯ä»¥ä¸Webæ¡†æ¶è¿›è¡Œé›†æˆï¼Œåªéœ€è¦åœ¨åŸæ¥ä¼ å…¥ä»»åŠ¡å‡½æ•°çš„åœ°æ–¹æ”¹ä¸ºä¼ å…¥åç¨‹å‡½æ•°å³å¯ã€‚"

#~ msgid "However, there are some limitations when using coroutine-based sessions to integrate into Flask or Django:"
#~ msgstr "ä½†å½“å‰åœ¨ä½¿ç”¨åŸºäºåç¨‹çš„ä¼šè¯é›†æˆè¿›Flaskæˆ–Djangoæ—¶ï¼Œå­˜åœ¨ä¸€äº›é™åˆ¶ï¼š"

#~ msgid ""
#~ "First, when ``await`` the coroutine objects/awaitable objects in the ``asyncio`` module, you need to use `run_asyncio_coroutine() <pywebio."
#~ "session.run_asyncio_coroutine>` to wrap the coroutine object."
#~ msgstr ""
#~ "ä¸€æ˜¯åç¨‹å‡½æ•°å†…è¿˜æ— æ³•ç›´æ¥é€šè¿‡ ``await`` ç›´æ¥ç­‰å¾…asyncioåº“ä¸­çš„åç¨‹å¯¹è±¡ï¼Œç›®å‰éœ€è¦ä½¿ç”¨ `run_asyncio_coroutine() <pywebio.session."
#~ "run_asyncio_coroutine>` è¿›è¡ŒåŒ…è£…ã€‚"

#~ msgid "Secondly, you need to start a new thread to run the event loop before starting a Flask/Django server."
#~ msgstr "äºŒæ˜¯ï¼Œåœ¨å¯åŠ¨Flask/Djangoè¿™ç±»åŸºäºçº¿ç¨‹çš„æœåŠ¡å™¨ä¹‹å‰éœ€è¦å¯åŠ¨ä¸€ä¸ªå•ç‹¬çš„çº¿ç¨‹æ¥è¿è¡Œäº‹ä»¶å¾ªç¯ã€‚"

#~ msgid "Example of coroutine-based session integration into Flask:"
#~ msgstr "ä½¿ç”¨åŸºäºåç¨‹çš„ä¼šè¯é›†æˆè¿›Flaskçš„ç¤ºä¾‹:"

#~ msgid ""
#~ "Finally, coroutine-based session is not available in the script mode. You always need to use ``start_server()`` to run coroutine task function "
#~ "or integrate it to a web framework."
#~ msgstr "æœ€åï¼Œä½¿ç”¨PyWebIOç¼–å†™çš„åç¨‹å‡½æ•°ä¸æ”¯æŒScriptæ¨¡å¼ï¼Œæ€»æ˜¯éœ€è¦ä½¿ç”¨ ``start_server`` æ¥å¯åŠ¨ä¸€ä¸ªæœåŠ¡æˆ–è€…é›†æˆè¿›Webæ¡†æ¶æ¥è°ƒç”¨ã€‚"

#~ msgid ""
#~ "You can use ``code`` parameter in :func:`pywebio.input.textarea()` to make a code editing textarea. This feature uses `Codemirror <https://"
#~ "codemirror.net/>`_ as underlying implementation. The ``code`` parameter accept the Codemirror options as a dict."
#~ msgstr ""
#~ ":func:`pywebio.input.textarea` è¿˜æ”¯æŒä½¿ç”¨ `Codemirror <https://codemirror.net/>`_ å®ç°ä»£ç é£æ ¼çš„ç¼–è¾‘åŒºï¼Œåªéœ€ä½¿ç”¨ ``code`` å‚æ•°ä¼ å…¥Codemirroræ”¯æŒ"
#~ "çš„é€‰é¡¹å³å¯(æœ€ç®€å•çš„æƒ…å†µæ˜¯ç›´æ¥ä¼ å…¥ ``code={}`` æˆ– ``code=True``):"

#~ msgid ""
#~ ":ref:`Here <codemirror_options>` are some commonly used Codemirror options. For complete Codemirror options, please visit: https://codemirror."
#~ "net/doc/manual.html#config"
#~ msgstr ":ref:`è¿™é‡Œ <codemirror_options>` åˆ—ä¸¾äº†ä¸€äº›å¸¸ç”¨çš„Codemirroré€‰é¡¹ï¼Œå®Œæ•´çš„Codemirroré€‰é¡¹è¯·è§ï¼šhttps://codemirror.net/doc/manual.html#config"

#~ msgid ""
#~ "Scopes can be nested. At the beginning, PyWebIO applications have only one ``ROOT`` Scope. Each time a new scope is created, the nesting level "
#~ "of the scope will increase by one level, and each time the current scope is exited, the nesting level of the scope will be reduced by one. "
#~ "PyWebIO uses the Scope stack to save the scope nesting level at runtime."
#~ msgstr ""
#~ "Scopeæ˜¯å¯åµŒå¥—çš„ï¼Œåˆå§‹æ¡ä»¶ä¸‹ï¼ŒPyWebIOåº”ç”¨åªæœ‰ä¸€ä¸ªæœ€é¡¶å±‚çš„ ``ROOT`` Scopeã€‚æ¯åˆ›å»ºä¸€ä¸ªæ–°Scopeï¼ŒScopeçš„åµŒå¥—å±‚çº§ä¾¿ä¼šå¤šåŠ ä¸€å±‚ï¼Œæ¯é€€å‡ºå½“å‰Scopeï¼ŒScopeçš„"
#~ "åµŒå¥—å±‚çº§ä¾¿ä¼šå‡å°‘ä¸€å±‚ã€‚PyWebIOä½¿ç”¨Scopeæ ˆæ¥ä¿å­˜è¿è¡Œæ—¶çš„Scopeçš„åµŒå¥—å±‚çº§ã€‚"

#~ msgid "For example, the following code will create 3 scopes:"
#~ msgstr "ä¾‹å¦‚ï¼Œå¦‚ä¸‹ä»£ç å°†ä¼šåˆ›å»º3ä¸ªScope:"

#~ msgid ""
#~ "Another way to deploy PyWebIO application as web service is using `path_deploy() <pywebio.platform.path_deploy>`. `path_deploy() <pywebio."
#~ "platform.path_deploy>` is used to deploy the PyWebIO applications from a directory. Each python file under this directory defines a PyWebIO "
#~ "application. You can access the application by using the file path as the URL. Refer to :ref:`platform module <dir_deploy>` for more information."
#~ msgstr ""
#~ "å°†PyWebIOåº”ç”¨éƒ¨ç½²ä¸ºwebæœåŠ¡çš„å¦ä¸€ç§æ–¹å¼æ˜¯ä½¿ç”¨ `path_deploy() <pywebio.platform.path_deploy>` ã€‚`path_deploy() <pywebio.platform.path_deploy>` å¯ä»¥"
#~ "ä»ä¸€ä¸ªç›®å½•ä¸­éƒ¨ç½²PyWebIOåº”ç”¨ï¼Œåªéœ€è¦åœ¨è¯¥ç›®å½•ä¸‹çš„pythonæ–‡ä»¶ä¸­å®šä¹‰PyWebIOåº”ç”¨ï¼Œå°±å¯ä»¥é€šè¿‡URLä¸­çš„è·¯å¾„æ¥è®¿é—®è¿™äº›åº”ç”¨äº†ã€‚"

#~ msgid "PyWebIO provides a series of functions to output text, tables, images, etc:"
#~ msgstr "PyWebIOæä¾›äº†ä¸€ç³»åˆ—å‡½æ•°æ¥è¾“å‡ºæ–‡æœ¬ã€è¡¨æ ¼ã€å›¾åƒç­‰æ ¼å¼:"

#~ msgid "**Placeholder**"
#~ msgstr "**å ä½ç¬¦**"

#~ msgid ""
#~ "When using combination output, if you want to dynamically update the ``put_xxx()`` content after it has been output, you can use the `output() "
#~ "<pywebio.output.output>` function. `output() <pywebio.output.output>` is like a placeholder, it can be passed in anywhere that ``put_xxx()`` can "
#~ "passed in. And after being output, the content can also be modified:"
#~ msgstr ""
#~ "ä½¿ç”¨ç»„åˆè¾“å‡ºæ—¶ï¼Œå¦‚æœæƒ³åœ¨å†…å®¹è¾“å‡ºåï¼Œå¯¹å…¶ä¸­çš„ ``put_xxx()`` å­é¡¹è¿›è¡ŒåŠ¨æ€ä¿®æ”¹ï¼Œå¯ä»¥ä½¿ç”¨ `output() <pywebio.output.output>` å‡½æ•°ï¼Œ\n"
#~ "`output() <pywebio.output.output>` å°±åƒä¸€ä¸ªå ä½ç¬¦ï¼Œå®ƒå¯ä»¥åƒ ``put_xxx()`` ä¸€æ ·ä¼ å…¥ `put_table` ã€ `popup` ã€ `put_widget` ç­‰å‡½æ•°ä¸­ä½œä¸ºè¾“å‡ºçš„ä¸€éƒ¨"
#~ "åˆ†ï¼Œ\n"
#~ "å¹¶ä¸”ï¼Œåœ¨è¾“å‡ºåï¼Œè¿˜å¯ä»¥å¯¹å…¶ä¸­çš„å†…å®¹è¿›è¡Œä¿®æ”¹(æ¯”å¦‚é‡ç½®æˆ–å¢åŠ å†…å®¹):"

#~ msgid "`set_scope(name) <pywebio.output.set_scope>` : Create scope at current location(or specified location)"
#~ msgstr "`set_scope(name) <pywebio.output.set_scope>` : åœ¨å½“å‰ä½ç½®ï¼ˆæˆ–æŒ‡å®šä½ç½®ï¼‰åˆ›å»ºscope"
